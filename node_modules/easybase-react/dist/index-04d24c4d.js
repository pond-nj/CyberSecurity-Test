var React = require('react');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function Frame(index) {
  return [];
}

var c$1 = {
  configureFrame: function configureFrame(_) {
    return {};
  },
  addRecord: function (_) {
    return Promise.resolve({});
  },
  deleteRecord: function (_) {
    return Promise.resolve({});
  },
  sync: function () {
    return Promise.resolve({});
  },
  updateRecordImage: function (_) {
    return Promise.resolve({});
  },
  updateRecordVideo: function (_) {
    return Promise.resolve({});
  },
  updateRecordFile: function (_) {
    return Promise.resolve({});
  },
  Frame: Frame,
  useFrameEffect: function useFrameEffect(_) {},
  fullTableSize: function () {
    return Promise.resolve(0);
  },
  tableTypes: function () {
    return Promise.resolve({});
  },
  currentConfiguration: function currentConfiguration() {
    return {};
  },
  Query: function (_) {
    return Promise.resolve([]);
  },
  getUserAttributes: function () {
    return Promise.resolve({});
  },
  isUserSignedIn: function isUserSignedIn() {
    return false;
  },
  setUserAttribute: function (_, _2) {
    return Promise.resolve({});
  },
  resetUserPassword: function (_, _2) {
    return Promise.resolve({});
  },
  signIn: function (_, _2) {
    return Promise.resolve({});
  },
  signOut: function signOut() {},
  signUp: function (_, _2, _3) {
    return Promise.resolve({});
  },
  onSignIn: function onSignIn(_) {},
  db: function db(_) {
    return {};
  },
  dbEventListener: function dbEventListener(_) {
    return function () {};
  },
  useReturn: function useReturn(_) {
    return {};
  },
  e: {},
  setFile: function (_, _2, _3, _4) {
    return Promise.resolve({});
  },
  setImage: function (_, _2, _3, _4) {
    return Promise.resolve({});
  },
  setVideo: function (_, _2, _3, _4) {
    return Promise.resolve({});
  },
  forgotPassword: function (_, _2) {
    return Promise.resolve({});
  },
  forgotPasswordConfirm: function (_, _2, _3) {
    return Promise.resolve({});
  },
  userID: function userID() {
    return undefined;
  }
};
var EasybaseContext = React.createContext(c$1);

// do not edit .js files directly - edit src/index.jst



var fastDeepEqual = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};

var POST_TYPES$1;

(function (POST_TYPES) {
  POST_TYPES["UPLOAD_ATTACHMENT"] = "upload_attachment";
  POST_TYPES["HANDSHAKE"] = "handshake";
  POST_TYPES["VALID_TOKEN"] = "valid_token";
  POST_TYPES["GET_FRAME"] = "get_frame";
  POST_TYPES["TABLE_SIZE"] = "table_size";
  POST_TYPES["COLUMN_TYPES"] = "column_types";
  POST_TYPES["SYNC_STACK"] = "sync_stack";
  POST_TYPES["SYNC_DELETE"] = "sync_delete";
  POST_TYPES["SYNC_INSERT"] = "sync_insert";
  POST_TYPES["GET_QUERY"] = "get_query";
  POST_TYPES["USER_ATTRIBUTES"] = "user_attributes";
  POST_TYPES["SET_ATTRIBUTE"] = "set_attribute";
  POST_TYPES["SIGN_UP"] = "sign_up";
  POST_TYPES["REQUEST_TOKEN"] = "request_token";
  POST_TYPES["EASY_QB"] = "easyqb";
  POST_TYPES["RESET_PASSWORD"] = "reset_password";
  POST_TYPES["FORGOT_PASSWORD_SEND"] = "forgot_password_send";
  POST_TYPES["FORGOT_PASSWORD_CONFIRM"] = "forgot_password_confirm";
})(POST_TYPES$1 || (POST_TYPES$1 = {}));

var DB_STATUS$1;

(function (DB_STATUS) {
  DB_STATUS["ERROR"] = "error";
  DB_STATUS["PENDING"] = "pending";
  DB_STATUS["SUCCESS"] = "success";
})(DB_STATUS$1 || (DB_STATUS$1 = {}));

var EXECUTE_COUNT$1;

(function (EXECUTE_COUNT) {
  EXECUTE_COUNT["ALL"] = "all";
  EXECUTE_COUNT["ONE"] = "one";
})(EXECUTE_COUNT$1 || (EXECUTE_COUNT$1 = {}));

var imageExtensions$1 = [
	"ase",
	"art",
	"bmp",
	"blp",
	"cd5",
	"cit",
	"cpt",
	"cr2",
	"cut",
	"dds",
	"dib",
	"djvu",
	"egt",
	"exif",
	"gif",
	"gpl",
	"grf",
	"icns",
	"ico",
	"iff",
	"jng",
	"jpeg",
	"jpg",
	"jfif",
	"jp2",
	"jps",
	"lbm",
	"max",
	"miff",
	"mng",
	"msp",
	"nitf",
	"ota",
	"pbm",
	"pc1",
	"pc2",
	"pc3",
	"pcf",
	"pcx",
	"pdn",
	"pgm",
	"PI1",
	"PI2",
	"PI3",
	"pict",
	"pct",
	"pnm",
	"pns",
	"ppm",
	"psb",
	"psd",
	"pdd",
	"psp",
	"px",
	"pxm",
	"pxr",
	"qfx",
	"raw",
	"rle",
	"sct",
	"sgi",
	"rgb",
	"int",
	"bw",
	"tga",
	"tiff",
	"tif",
	"vtf",
	"xbm",
	"xcf",
	"xpm",
	"3dv",
	"amf",
	"ai",
	"awg",
	"cgm",
	"cdr",
	"cmx",
	"dxf",
	"e2d",
	"egt",
	"eps",
	"fs",
	"gbr",
	"odg",
	"svg",
	"stl",
	"vrml",
	"x3d",
	"sxd",
	"v2d",
	"vnd",
	"wmf",
	"emf",
	"art",
	"xar",
	"png",
	"webp",
	"jxr",
	"hdp",
	"wdp",
	"cur",
	"ecw",
	"iff",
	"lbm",
	"liff",
	"nrrd",
	"pam",
	"pcx",
	"pgf",
	"sgi",
	"rgb",
	"rgba",
	"bw",
	"int",
	"inta",
	"sid",
	"ras",
	"sun",
	"tga"
];

var videoExtensions$1 = [
	"3g2",
	"3gp",
	"aaf",
	"asf",
	"avchd",
	"avi",
	"drc",
	"flv",
	"m2v",
	"m4p",
	"m4v",
	"mkv",
	"mng",
	"mov",
	"mp2",
	"mp4",
	"mpe",
	"mpeg",
	"mpg",
	"mpv",
	"mxf",
	"nsv",
	"ogg",
	"ogv",
	"qt",
	"rm",
	"rmvb",
	"roq",
	"svi",
	"vob",
	"webm",
	"wmv",
	"yuv"
];

var GlobalNamespace;
(function (GlobalNamespace) {
})(GlobalNamespace || (GlobalNamespace = {}));
const _g = { ...GlobalNamespace };
function gFactory({ ebconfig, options }) {
    const optionsObj = { ...options }; // Forces undefined to empty object
    const gaTrackingObj = options ? options.googleAnalyticsEventTracking : {};
    const defaultG = {
        options: optionsObj,
        ebconfig: ebconfig,
        GA_USER_ID_SALT: "m83WnAPrq",
        analyticsEventsToTrack: {
            login: true,
            sign_up: true,
            forgot_password: true,
            forgot_password_confirm: true,
            reset_user_password: true,
            ...gaTrackingObj
        }
    };
    return { ...GlobalNamespace, ...defaultG };
}

function utilsFactory(globals) {
    const g = globals || _g;
    const generateBareUrl = (type, integrationID) => `https://api.easybase.io/${type}/${integrationID}`;
    const generateAuthBody = () => {
        const stamp = Date.now();
        return {
            token: g.token,
            token_time: ~~(g.session / (stamp % 64)),
            now: stamp
        };
    };
    function log(...params) {
        if (g.options.logging) {
            console.log("EASYBASE â€” ", ...params);
        }
    }
    return {
        generateAuthBody,
        generateBareUrl,
        log
    };
}

var POST_TYPES;
(function (POST_TYPES) {
    POST_TYPES["UPLOAD_ATTACHMENT"] = "upload_attachment";
    POST_TYPES["HANDSHAKE"] = "handshake";
    POST_TYPES["VALID_TOKEN"] = "valid_token";
    POST_TYPES["GET_FRAME"] = "get_frame";
    POST_TYPES["TABLE_SIZE"] = "table_size";
    POST_TYPES["COLUMN_TYPES"] = "column_types";
    POST_TYPES["SYNC_STACK"] = "sync_stack";
    POST_TYPES["SYNC_DELETE"] = "sync_delete";
    POST_TYPES["SYNC_INSERT"] = "sync_insert";
    POST_TYPES["GET_QUERY"] = "get_query";
    POST_TYPES["USER_ATTRIBUTES"] = "user_attributes";
    POST_TYPES["SET_ATTRIBUTE"] = "set_attribute";
    POST_TYPES["SIGN_UP"] = "sign_up";
    POST_TYPES["REQUEST_TOKEN"] = "request_token";
    POST_TYPES["EASY_QB"] = "easyqb";
    POST_TYPES["RESET_PASSWORD"] = "reset_password";
    POST_TYPES["FORGOT_PASSWORD_SEND"] = "forgot_password_send";
    POST_TYPES["FORGOT_PASSWORD_CONFIRM"] = "forgot_password_confirm";
})(POST_TYPES || (POST_TYPES = {}));
var DB_STATUS;
(function (DB_STATUS) {
    DB_STATUS["ERROR"] = "error";
    DB_STATUS["PENDING"] = "pending";
    DB_STATUS["SUCCESS"] = "success";
})(DB_STATUS || (DB_STATUS = {}));
var EXECUTE_COUNT;
(function (EXECUTE_COUNT) {
    EXECUTE_COUNT["ALL"] = "all";
    EXECUTE_COUNT["ONE"] = "one";
})(EXECUTE_COUNT || (EXECUTE_COUNT = {}));

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn) {
  var module = { exports: {} };
	return fn(module, module.exports), module.exports;
}

var browserPonyfill = createCommonjsModule(function (module, exports) {
var global = typeof self !== 'undefined' ? self : commonjsGlobal;
var __self__ = (function () {
function F() {
this.fetch = false;
this.DOMException = global.DOMException;
}
F.prototype = global;
return new F();
})();
(function(self) {

((function (exports) {

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob:
      'FileReader' in self &&
      'Blob' in self &&
      (function() {
        try {
          new Blob();
          return true
        } catch (e) {
          return false
        }
      })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  };

  function isDataView(obj) {
    return obj && DataView.prototype.isPrototypeOf(obj)
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ];

    var isArrayBufferView =
      ArrayBuffer.isView ||
      function(obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
      };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return {done: value === undefined, value: value}
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      };
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue + ', ' + value : value;
  };

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null
  };

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  };

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };

  Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push(name);
    });
    return iteratorFor(items)
  };

  Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) {
      items.push(value);
    });
    return iteratorFor(items)
  };

  Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push([name, value]);
    });
    return iteratorFor(items)
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function(body) {
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        this._bodyText = body = Object.prototype.toString.call(body);
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      };

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      };
    }

    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    };

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      };
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    };

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods.indexOf(upcased) > -1 ? upcased : method
  }

  function Request(input, options) {
    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      this.signal = input.signal;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'same-origin';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.signal = options.signal || this.signal;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body);
  }

  Request.prototype.clone = function() {
    return new Request(this, {body: this._bodyInit})
  };

  function decode(body) {
    var form = new FormData();
    body
      .trim()
      .split('&')
      .forEach(function(bytes) {
        if (bytes) {
          var split = bytes.split('=');
          var name = split.shift().replace(/\+/g, ' ');
          var value = split.join('=').replace(/\+/g, ' ');
          form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
      });
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
    // https://tools.ietf.org/html/rfc7230#section-3.2
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
    preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':');
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(':').trim();
        headers.append(key, value);
      }
    });
    return headers
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = options.status === undefined ? 200 : options.status;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = 'statusText' in options ? options.statusText : 'OK';
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  };

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''});
    response.type = 'error';
    return response
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  };

  exports.DOMException = self.DOMException;
  try {
    new exports.DOMException();
  } catch (err) {
    exports.DOMException = function(message, name) {
      this.message = message;
      this.name = name;
      var error = Error(message);
      this.stack = error.stack;
    };
    exports.DOMException.prototype = Object.create(Error.prototype);
    exports.DOMException.prototype.constructor = exports.DOMException;
  }

  function fetch(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init);

      if (request.signal && request.signal.aborted) {
        return reject(new exports.DOMException('Aborted', 'AbortError'))
      }

      var xhr = new XMLHttpRequest();

      function abortXhr() {
        xhr.abort();
      }

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options));
      };

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.onabort = function() {
        reject(new exports.DOMException('Aborted', 'AbortError'));
      };

      xhr.open(request.method, request.url, true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      } else if (request.credentials === 'omit') {
        xhr.withCredentials = false;
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob';
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });

      if (request.signal) {
        request.signal.addEventListener('abort', abortXhr);

        xhr.onreadystatechange = function() {
          // DONE (success or failure)
          if (xhr.readyState === 4) {
            request.signal.removeEventListener('abort', abortXhr);
          }
        };
      }

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    })
  }

  fetch.polyfill = true;

  if (!self.fetch) {
    self.fetch = fetch;
    self.Headers = Headers;
    self.Request = Request;
    self.Response = Response;
  }

  exports.Headers = Headers;
  exports.Request = Request;
  exports.Response = Response;
  exports.fetch = fetch;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

})({}));
})(__self__);
__self__.fetch.ponyfill = true;
// Remove "polyfill" property added by whatwg-fetch
delete __self__.fetch.polyfill;
// Choose between native implementation (global) or custom implementation (__self__)
// var ctx = global.fetch ? global : __self__;
var ctx = __self__; // this line disable service worker support temporarily
exports = ctx.fetch; // To enable: import fetch from 'cross-fetch'
exports.default = ctx.fetch; // For TypeScript consumers without esModuleInterop.
exports.fetch = ctx.fetch; // To enable: import {fetch} from 'cross-fetch'
exports.Headers = ctx.Headers;
exports.Request = ctx.Request;
exports.Response = ctx.Response;
module.exports = exports;
});

var fetch = /*@__PURE__*/getDefaultExportFromCjs(browserPonyfill);

function authFactory(globals) {
    const g = globals || _g;
    const { generateBareUrl, generateAuthBody, log } = utilsFactory(g);
    function _clearTokens() {
        g.token = "";
        g.refreshToken = "";
        g.newTokenCallback();
        g.userID = undefined;
    }
    const getUserAttributes = async () => {
        try {
            const attrsRes = await tokenPost(POST_TYPES.USER_ATTRIBUTES);
            g.analyticsEnabled && g.analyticsEventsToTrack.get_user_attributes && g.analyticsEvent('get_user_attributes');
            return attrsRes.data;
        }
        catch (error) {
            log(error);
            return error;
        }
    };
    const setUserAttribute = async (key, value) => {
        try {
            const setAttrsRes = await tokenPost(POST_TYPES.SET_ATTRIBUTE, {
                key,
                value
            });
            g.analyticsEnabled && g.analyticsEventsToTrack.set_user_attribute && g.analyticsEvent('set_user_attribute', { key });
            return {
                success: setAttrsRes.success,
                message: JSON.stringify(setAttrsRes.data)
            };
        }
        catch (error) {
            return {
                success: false,
                message: error.message || "Error",
                errorCode: error.errorCode || undefined
            };
        }
    };
    const forgotPassword = async (username, emailTemplate) => {
        try {
            const setAttrsRes = await tokenPost(POST_TYPES.FORGOT_PASSWORD_SEND, {
                username,
                emailTemplate
            });
            g.analyticsEnabled && g.analyticsEventsToTrack.forgot_password && g.analyticsEvent('forgot_password');
            return {
                success: setAttrsRes.success,
                message: setAttrsRes.data
            };
        }
        catch (error) {
            return {
                success: false,
                message: error.message || "Error",
                errorCode: error.errorCode || undefined
            };
        }
    };
    const forgotPasswordConfirm = async (code, username, newPassword) => {
        try {
            const setAttrsRes = await tokenPost(POST_TYPES.FORGOT_PASSWORD_CONFIRM, {
                username,
                code,
                newPassword
            });
            g.analyticsEnabled && g.analyticsEventsToTrack.forgot_password_confirm && g.analyticsEvent('forgot_password_confirm');
            return {
                success: setAttrsRes.success,
                message: setAttrsRes.data
            };
        }
        catch (error) {
            return {
                success: false,
                message: error.message || "Error",
                errorCode: error.errorCode || undefined
            };
        }
    };
    const signUp = async (newUserID, password, userAttributes) => {
        try {
            const signUpRes = await tokenPost(POST_TYPES.SIGN_UP, {
                newUserID,
                password,
                userAttributes
            });
            g.analyticsEnabled && g.analyticsEventsToTrack.sign_up && g.analyticsEvent('sign_up', { method: "Easybase" });
            return {
                success: signUpRes.success,
                message: signUpRes.data
            };
        }
        catch (error) {
            return {
                success: false,
                message: error.message || "Error",
                errorCode: error.errorCode || undefined
            };
        }
    };
    const signIn = async (userID, password) => {
        const t1 = Date.now();
        g.session = Math.floor(100000000 + Math.random() * 900000000);
        const integrationType = g.ebconfig.integration.split("-")[0].toUpperCase() === "PROJECT" ? "PROJECT" : "REACT";
        try {
            const res = await fetch(generateBareUrl(integrationType, g.ebconfig.integration), {
                method: "POST",
                headers: {
                    'Eb-Post-Req': POST_TYPES.HANDSHAKE,
                    'Accept': 'application/json',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    version: g.ebconfig.version,
                    session: g.session,
                    instance: g.instance,
                    userID,
                    password
                })
            });
            const resData = await res.json();
            if (resData.token) {
                g.token = resData.token;
                g.refreshToken = resData.refreshToken;
                g.newTokenCallback();
                g.userID = resData.userID;
                g.mounted = true;
                const [validTokenRes, { hash }, { fromUtf8 }] = await Promise.all([tokenPost(POST_TYPES.VALID_TOKEN), Promise.resolve().then(function () { return require('./sha256-af354191.js'); }).then(function (n) { return n.sha256; }), Promise.resolve().then(function () { return require('./index-3188f313.js'); })]);
                const elapsed = Date.now() - t1;
                if (validTokenRes.success) {
                    log("Valid auth initiation in " + elapsed + "ms");
                    if (g.analyticsEnabled && g.analyticsEventsToTrack.login) {
                        const hashOut = hash(fromUtf8(g.GA_USER_ID_SALT + resData.userID));
                        const hexHash = Array.prototype.map.call(hashOut, x => ('00' + x.toString(16)).slice(-2)).join('');
                        g.analyticsIdentify(hexHash);
                        g.analyticsEvent('login', { method: "Easybase" });
                    }
                    return {
                        success: true,
                        message: "Successfully signed in user"
                    };
                }
                else {
                    return {
                        success: false,
                        message: "Could not sign in user"
                    };
                }
            }
            else {
                return {
                    success: false,
                    message: "Could not sign in user",
                    errorCode: resData.ErrorCode || undefined
                };
            }
        }
        catch (error) {
            return {
                success: false,
                message: error.message || "Could not sign in user",
                errorCode: error.errorCode || undefined
            };
        }
    };
    const resetUserPassword = async (currentPassword, newPassword) => {
        if (typeof newPassword !== "string" || newPassword.length > 100) {
            return {
                success: false,
                message: "newPassword must be of type string"
            };
        }
        if (typeof currentPassword !== "string" || currentPassword.length > 100) {
            return {
                success: false,
                message: "currentPassword must be of type string"
            };
        }
        try {
            const setAttrsRes = await tokenPost(POST_TYPES.RESET_PASSWORD, { currentPassword, newPassword });
            g.analyticsEnabled && g.analyticsEventsToTrack.reset_user_password && g.analyticsEvent('reset_user_password');
            return {
                success: setAttrsRes.success,
                message: JSON.stringify(setAttrsRes.data)
            };
        }
        catch (error) {
            return {
                success: false,
                message: error.message || "Error",
                errorCode: error.errorCode || undefined
            };
        }
    };
    const userID = () => g.userID || undefined;
    const signOut = () => {
        g.token = "";
        g.newTokenCallback();
        g.userID = undefined;
    };
    const initAuth = async () => {
        const t1 = Date.now();
        g.session = Math.floor(100000000 + Math.random() * 900000000);
        log(`Handshaking on${g.instance} instance`);
        const integrationType = g.ebconfig.integration.split("-")[0].toUpperCase() === "PROJECT" ? "PROJECT" : "REACT";
        try {
            const res = await fetch(generateBareUrl(integrationType, g.ebconfig.integration), {
                method: "POST",
                headers: {
                    'Eb-Post-Req': POST_TYPES.HANDSHAKE,
                    'Accept': 'application/json',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    version: g.ebconfig.version,
                    tt: g.ebconfig.tt,
                    session: g.session,
                    instance: g.instance
                })
            });
            const resData = await res.json();
            if (resData.token) {
                g.token = resData.token;
                g.mounted = true;
                const validTokenRes = await tokenPost(POST_TYPES.VALID_TOKEN);
                const elapsed = Date.now() - t1;
                if (validTokenRes.success) {
                    log("Valid auth initiation in " + elapsed + "ms");
                    return true;
                }
                else {
                    return false;
                }
            }
            else {
                return false;
            }
        }
        catch (error) {
            console.error(error);
            return false;
        }
    };
    const tokenPost = async (postType, body) => {
        if (!g.mounted) {
            await initAuth();
        }
        const integrationType = g.ebconfig.integration.split("-")[0].toUpperCase() === "PROJECT" ? "PROJECT" : "REACT";
        const res = await fetch(generateBareUrl(integrationType, g.ebconfig.integration), {
            method: "POST",
            headers: {
                'Eb-Post-Req': postType,
                'Accept': 'application/json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                _auth: generateAuthBody(),
                ...body
            })
        });
        const resData = await res.json();
        if ({}.hasOwnProperty.call(resData, 'ErrorCode') || {}.hasOwnProperty.call(resData, 'code')) {
            if (resData.ErrorCode === "TokenExpired") {
                if (integrationType === "PROJECT") {
                    try {
                        const req_res = await tokenPost(POST_TYPES.REQUEST_TOKEN, {
                            refreshToken: g.refreshToken,
                            token: g.token
                        });
                        if (req_res.success) {
                            g.token = req_res.data.token;
                            g.newTokenCallback();
                            return tokenPost(postType, body);
                        }
                        else {
                            throw new Error(req_res.data || "Error");
                        }
                    }
                    catch (error) {
                        _clearTokens();
                        return {
                            success: false,
                            data: error.message || error
                        };
                    }
                }
                else {
                    await initAuth();
                }
                return tokenPost(postType, body);
            }
            else {
                const err = new Error(resData.body || resData.ErrorCode || resData.code || "Error");
                err.errorCode = resData.ErrorCode || resData.code;
                throw err;
            }
        }
        else {
            return {
                success: resData.success,
                data: resData.body
            };
        }
    };
    const tokenPostAttachment = async (formData, customHeaders) => {
        if (!g.mounted) {
            await initAuth();
        }
        const regularAuthbody = generateAuthBody();
        const attachmentAuth = {
            'Eb-token': regularAuthbody.token,
            'Eb-token-time': regularAuthbody.token_time,
            'Eb-now': regularAuthbody.now
        };
        const integrationType = g.ebconfig.integration.split("-")[0].toUpperCase() === "PROJECT" ? "PROJECT" : "REACT";
        const res = await fetch(generateBareUrl(integrationType, g.ebconfig.integration), {
            method: "POST",
            headers: {
                'Eb-Post-Req': POST_TYPES.UPLOAD_ATTACHMENT,
                ...customHeaders,
                ...attachmentAuth
            },
            body: formData
        });
        const resData = await res.json();
        if ({}.hasOwnProperty.call(resData, 'ErrorCode') || {}.hasOwnProperty.call(resData, 'code')) {
            if (resData.ErrorCode === "TokenExpired") {
                if (integrationType === "PROJECT") {
                    try {
                        const req_res = await tokenPost(POST_TYPES.REQUEST_TOKEN, {
                            refreshToken: g.refreshToken,
                            token: g.token
                        });
                        if (req_res.success) {
                            g.token = req_res.data.token;
                            g.newTokenCallback();
                            return tokenPostAttachment(formData, customHeaders);
                        }
                        else {
                            throw new Error(req_res.data || "Error");
                        }
                    }
                    catch (error) {
                        _clearTokens();
                        return {
                            success: false,
                            data: error.message || error
                        };
                    }
                }
                else {
                    await initAuth();
                }
                return tokenPostAttachment(formData, customHeaders);
            }
            else {
                const err = new Error(resData.body || resData.ErrorCode || resData.code || "Error");
                err.errorCode = resData.ErrorCode || resData.code;
                throw err;
            }
        }
        else {
            return {
                success: resData.success,
                data: resData.body
            };
        }
    };
    return {
        initAuth,
        tokenPost,
        tokenPostAttachment,
        signUp,
        setUserAttribute,
        getUserAttributes,
        signIn,
        signOut,
        resetUserPassword,
        forgotPassword,
        forgotPasswordConfirm,
        userID
    };
}

function tableFactory(globals) {
    const g = globals || _g;
    const { tokenPost } = authFactory(g);
    const Query = async (options) => {
        const defaultOptions = {
            queryName: ""
        };
        const fullOptions = { ...defaultOptions, ...options };
        const res = await tokenPost(POST_TYPES.GET_QUERY, fullOptions);
        if (res.success) {
            g.analyticsEnabled && g.analyticsEventsToTrack.query && g.analyticsEvent('query', { queryName: fullOptions.queryName, tableName: fullOptions.tableName || undefined });
            return res.data;
        }
        else {
            return [];
        }
    };
    async function fullTableSize(tableName) {
        const res = await tokenPost(POST_TYPES.TABLE_SIZE, tableName ? { tableName } : {});
        if (res.success) {
            g.analyticsEnabled && g.analyticsEventsToTrack.full_table_size && g.analyticsEvent('full_table_size', { tableName: tableName || undefined });
            return res.data;
        }
        else {
            return 0;
        }
    }
    async function tableTypes(tableName) {
        const res = await tokenPost(POST_TYPES.COLUMN_TYPES, tableName ? { tableName } : {});
        if (res.success) {
            g.analyticsEnabled && g.analyticsEventsToTrack.table_types && g.analyticsEvent('table_types', { tableName: tableName || undefined });
            return res.data;
        }
        else {
            return {};
        }
    }
    return {
        Query,
        fullTableSize,
        tableTypes
    };
}

/** Returns a function the creates a new context */
const createNewContext$1 = defaultContext => {
    const { parameterize, escape, mapKey, build } = defaultContext;

    return (inherit = {}) => {
        const { params = [], unparameterized = false } = inherit;

        const whr = [];
        return {
            // properties set by the EasyQB instance
            parameterize,
            escape,
            mapKey,
            build,

            // properties inherited from the parent query
            params,
            unparameterized,

            // properties of the current query
            type: 'select',
            // | sql' | 'select' | 'delete' | 'insert' | 'update'
            target: whr,
            join: undefined,
            separator: ' ',
            sql: [],
            ret: [],
            frm: [],
            whr,
            grp: [],
            hav: [],
            setop: [],
            ord: [],
            with: [],
            set: []

            // properties that may be added dynamically:
            // userType
            // distinct
        }
    }
};

var context = createNewContext$1;

const createQueryBuilder = ({ defaultContext, query, e, config }) => {
    const { queries, methods, properties } = query;
    const newContext = context(defaultContext);
    const reducers = createReducers(methods);
    const updateContext = applyReducers(reducers);
    reducers.extend = (ctx, args) => {
        const arr = Array.isArray(args[0]) ? args[0] : args;
        for (let i = 0; i < arr.length; ++i) {
            updateContext(arr[i].method, ctx);
        }
    };
    const builder = () => { }; // must not be object literal
    const chain = createChain$1(builder);

    const executeProperties = {
        one: {
            value: async function () {
                const ret = await config.oneCallback(this.query, config.tableName, config.userAssociatedRecordsOnly);
                return ret;
            }
        },
        all: {
            value: async function () {
                const ret = await config.allCallback(this.query, config.tableName, config.userAssociatedRecordsOnly);
                return ret;
            }
        },
        _tableName: {
            get: function () {
                return config.tableName
            }
        }
    };

    // EasyQB no access to from
    const _methodProperties = methodProperties$1({ methods, chain });
    delete _methodProperties.from;

    Object.defineProperties(builder, {
        ...builderProperties$1({ chain, newContext, updateContext, queries }),
        ..._methodProperties,
        ...executeProperties,
        ...properties,
        e: {
            value: e
        }
    });
    return chain()
};

/** Creates a new builder instance */
const createChain$1 = prototype => {
    const chain = method => {
        const fn = (...args) => chain({ name: 'express', args, prev: method });
        fn.method = method;
        Object.setPrototypeOf(fn, prototype);
        return fn
    };
    return chain
};

/** Creates an object containing all method reducers */
const createReducers = methods => {
    const reducers = {};
    for (const name in methods) {
        const { updateContext, properties = {} } = methods[name];
        reducers[name] = updateContext;
        // some methods have subproperties, e.g. .unionAll
        for (const key in properties) {
            reducers[`${name}.${key}`] = properties[key];
        }
    }
    return reducers
};

/** Follows a method chain, applying each method's reducer, to ctx */
const applyReducers = reducers => (method, ctx) => {
    // follow method links to construct methods array (in reverse)
    const methods = [];
    for (; method !== undefined; method = method.prev) {
        methods.push(method);
    }
    // build methods object by processing methods in call order
    const express = { id: 0 };
    for (let i = methods.length - 1; i >= 0; --i) {
        const method = methods[i];
        reducers[method.name](ctx, method.args, express);
    }
    return ctx
};

/** Default properties of all SQL Query Builders */
const builderProperties$1 = ({ newContext, updateContext, queries }) => ({
    _build: {
        value: function (inheritedContext) {
            const ctx = updateContext(this.method, newContext(inheritedContext));
            return queries[ctx.type](ctx)
        }
    },
    query: {
        get: function () {
            return this._build()
        }
    },
    unparameterized: {
        get: function () {
            return this._build({ unparameterized: true }).text
        }
    }
});

/** Builds object containing a property for every query building method */
const methodProperties$1 = ({ methods, chain }) => {
    const properties = {};
    for (const name in methods) {
        const { getter } = methods[name];
        if (getter) {
            // add getter methods
            properties[name] = {
                get: function () {
                    return chain({ name, prev: this.method })
                }
            };
        } else {
            // add function call methods
            properties[name] = {
                value: function (...args) {
                    return chain({ name, args, prev: this.method })
                }
            };
        }
    }
    return properties
};

var builderSq = createQueryBuilder;

const isTaggedTemplate$5 = ([strings]) => Array.isArray(strings) && strings.raw;

const buildTaggedTemplate$5 = (ctx, [strings, ...args]) => {
  let txt = strings[0];
  for (let i = 0; i < args.length; ++i) {
    txt += ctx.build(args[i]) + strings[i + 1];
  }
  return txt
};

var tagged_template = {
  isTaggedTemplate: isTaggedTemplate$5,
  buildTaggedTemplate: buildTaggedTemplate$5
};

const { isTaggedTemplate: isTaggedTemplate$4, buildTaggedTemplate: buildTaggedTemplate$4 } = tagged_template;

const isObject$6 = arg => arg && arg.constructor.prototype === Object.prototype;

const buildCall$8 = callbackfn => (ctx, args) =>
  isTaggedTemplate$4(args)
    ? buildTaggedTemplate$4(ctx, args)
    : callbackfn(ctx, args);

const mapJoin$8 = (callbackfn, separator = ', ') => (ctx, args) => {
  let txt = '';
  for (let i = 0; i < args.length; ++i) {
    if (i !== 0) txt += separator;
    txt += callbackfn(ctx, args[i]);
  }
  return txt
};

const mapJoinWrap$1 = (callbackfn, separator = ', ', open = '(', close = ')') => (
  ctx,
  args
) => {
  let txt = open;
  for (let i = 0; i < args.length; ++i) {
    if (i !== 0) txt += separator;
    txt += callbackfn(ctx, args[i]);
  }
  return txt + close
};

const objectMapJoin$5 = (callbackfn, separator = ', ') => (ctx, object) => {
  let txt = '';
  const keys = Object.keys(object);
  for (let i = 0; i < keys.length; ++i) {
    if (i !== 0) txt += separator;
    const key = keys[i];
    txt += callbackfn(ctx, key, object[key]);
  }
  return txt
};

var build_utils = {
  isObject: isObject$6,
  buildCall: buildCall$8,
  mapJoin: mapJoin$8,
  mapJoinWrap: mapJoinWrap$1,
  objectMapJoin: objectMapJoin$5
};

// included to mitigate cost of case conversion
const memoize$1 = fn => {
  const cache = {};
  return key => cache[key] || (cache[key] = fn(key))
};

const normalKey$3 = given_key => given_key.indexOf('(') === -1 ? given_key.toLowerCase().trim().replace(/ /g, '_') : given_key;

var change_case = {
  memoize: memoize$1,
  normalKey: normalKey$3
};

var libUtil = {
  ...build_utils,
  ...change_case,
  ...tagged_template
};

const { isTaggedTemplate: isTaggedTemplate$3 } = libUtil;

const createExpressionCompiler = expressionTable => {
  const callsCompiler = createCallsCompiler(expressionTable);
  return (ctx, current) => {
    const calls = buildCalls(current);
    const text = callsCompiler(ctx, calls);
    return {
      text,
      args: ctx.params,
      type: 'expression'
    }
  }
};

// TODO: Performance optimization:
// inline expression building with this method so at most only one array
// is allocated in total, no array of object containing arrays nonsense
const buildCalls = current => {
  // get call nodes
  const calls = [];
  for (; current; current = current.prev) calls.push(current);
  if (calls.length === 0) throw Error('Error: Empty expression')

  // build expression list
  let expression = { name: 'arg', args: [] };
  const expressions = [expression];
  const last = calls.length - 1;
  for (let i = last; i >= 0; --i) {
    const { name, args } = calls[i];
    if (i === last) {
      if (name) expression.name = name;
      else pushCall(expression.args, args);
    } else {
      if (name) expressions.push((expression = { name, args: [undefined] }));
      else pushCall(expression.args, args);
    }
  }
  return expressions
};

const pushCall = (array, args) => {
  if (isTaggedTemplate$3(args)) {
    array.push({ tag: args });
  } else {
    if (args.length === 0)
      throw Error('Error: Expression call requires at least one argument')
    for (let i = 0; i < args.length; ++i) {
      array.push({ arg: args[i] });
    }
  }
};

const createCallsCompiler = expressionTable => (ctx, calls) => {
  let exp;
  for (let i = 0; i < calls.length; ++i) {
    const { name, args } = calls[i];
    const { build, minArgs, maxArgs } = expressionTable[name];
    if (i !== 0) args[0] = { exp };
    const numArgs = args.length;
    if (numArgs < minArgs)
      throw Error(`Error: ${name} requires at least ${minArgs} arguments`)
    if (numArgs > maxArgs)
      throw Error(`Error: ${name} accepts at most ${maxArgs} arguments`)
    exp = build(ctx, args);
  }
  return exp
};

var compile = createExpressionCompiler;

const { normalKey: normalKey$2 } = libUtil;

const aggregator = (op) => (columnName) => `${op}(${normalKey$2(columnName)})`;

var builderExpression = ({ defaultContext, expression }) => {
  const { expressions } = expression;
  const newContext = createNewContext(defaultContext);
  const compile$1 = compile(expressions);
  const builder = () => {}; // must not be object literal
  const chain = createChain(builder);
  Object.defineProperties(builder, {
    ...builderProperties({ compile: compile$1, newContext }),
    ...methodProperties({ expressions, chain }),
  });
  const ret = chain();
  ret.max = aggregator('max');
  ret.min = aggregator('min');
  ret.avg = aggregator('avg');
  ret.count = aggregator('count');
  ret.sum = aggregator('sum');
  return ret;
};

const builderProperties = ({ compile, newContext }) => ({
  _build: {
    value: function(inherit) {
      return compile(newContext(inherit), this.current)
    }
  },
  query: {
    get: function() {
      return this._build()
    }
  },
  unparameterized: {
    get: function() {
      return this._build({ unparameterized: true }).text
    }
  }
});

const createNewContext = defaultContext => {
  const { build, parameterize, escape, mapKey } = defaultContext;
  return inherit => {
    const { params = [], unparameterized = false } = inherit || {};
    return {
      // EasyQB instance properties
      build,
      parameterize,
      escape,
      mapKey,

      // inherited properties
      params,
      unparameterized
    }
  }
};

const createChain = prototype => {
  const chain = current => {
    const fn = (...args) => chain({ prev: current, args });
    fn.current = current;
    Object.setPrototypeOf(fn, prototype);
    return fn
  };
  return chain
};

const methodProperties = ({ expressions, chain }) => {
  const properties = {};
  for (const name in expressions) {
    properties[name] = {
      get: function() {
        return chain({ prev: this.current, name })
      }
    };
  }
  return properties
};

const { memoize, normalKey: normalKey$1 } = libUtil;


/**
 * Creates a version of EasyQB for the given SQL dialect and database adapter.
 *
 * A dialect is variant of the SQL language,
 * while an adapter is the driver that communicates with the database.
 *
 * This design makes it easy to swap drivers, e.g. mysql vs mysql2 or
 * add new databases just by connecting a new adapter to an existing dialect.
 *
 */

const createSqorn = ({ dialect }) => (config = {}) => {
  const { query, expression, parameterize, escape } = dialect;

  // 1. Create default context properties passed through build tree
  const mapKey = memoize(normalKey$1);
  const defaultContext = { parameterize, escape, mapKey, build: build$1 };

  // 2. Create Expression Builder
  const e = builderExpression({ defaultContext, expression });

  // 3. Create Query Builder
  const sq = builderSq({ defaultContext, query, e, config });

  // 4. TODO: Build Executor, Attach e and execute functions

  // 5. TODO: Return { sq, e, transaction, db }
  return sq
};

function build$1(arg) {
  if (arg === undefined) throw Error('Error: undefined argument')
  if (typeof arg === 'function') {
    if (arg._build) {
      const { type, text } = arg._build(this);
      if (type === 'expression') return text
      if (type === 'fragment') return text
      return `(${text})`
    }
    return arg(this)
  }
  return this.unparameterized ? this.escape(arg) : this.parameterize(arg)
}

var libCore = createSqorn;

const { normalKey } = libUtil;

/** Query building methods */
const methods$1 = {
    with: {
        updateContext: (ctx, args) => {
            ctx.with.push(args);
        }
    },
    withRecursive: {
        updateContext: (ctx, args) => {
            ctx.recursive = true;
            ctx.with.push(args);
        }
    },
    from: {
        updateContext: (ctx, args) => {
            ctx.frm.push({ args, join: ', ' });
        }
    },
    where: {
        updateContext: (ctx, args) => {
            ctx.whr.push(args);
            ctx.target = ctx.whr;
        }
    },
    return: {
        updateContext: (ctx, args) => {
            ctx.ret.push(Array.isArray(args) ? args.map(normalKey) : args);
        }
    },
    distinct: {
        getter: true,
        updateContext: ctx => {
            ctx.distinct = [];
        }
    },
    groupBy: {
        updateContext: (ctx, args) => {
            ctx.grp.push(args);
        }
    },
    having: {
        updateContext: (ctx, args) => {
            ctx.hav.push(args);
            ctx.target = ctx.hav;
        }
    },
    union: {
        updateContext: (ctx, args) => {
            ctx.setop.push({ type: 'union', args });
        }
    },
    unionAll: {
        updateContext: (ctx, args) => {
            ctx.setop.push({ type: 'union all', args });
        }
    },
    intersect: {
        updateContext: (ctx, args) => {
            ctx.setop.push({ type: 'intersect', args });
        }
    },
    intersectAll: {
        updateContext: (ctx, args) => {
            ctx.setop.push({ type: 'intersect all', args });
        }
    },
    except: {
        updateContext: (ctx, args) => {
            ctx.setop.push({ type: 'except', args });
        }
    },
    exceptAll: {
        updateContext: (ctx, args) => {
            ctx.setop.push({ type: 'except all', args });
        }
    },
    orderBy: {
        updateContext: (ctx, args) => {
            ctx.ord.push(args);
        }
    },
    limit: {
        updateContext: (ctx, args) => {
            ctx.limit = args;
        }
    },
    offset: {
        updateContext: (ctx, args) => {
            ctx.offset = args;
        }
    },
    join: {
        updateContext: (ctx, args) => {
            ctx.frm.push((ctx.join = { args, join: ' join ' }));
        }
    },
    leftJoin: {
        updateContext: (ctx, args) => {
            ctx.frm.push((ctx.join = { args, join: ' left join ' }));
        }
    },
    rightJoin: {
        updateContext: (ctx, args) => {
            ctx.frm.push((ctx.join = { args, join: ' right join ' }));
        }
    },
    fullJoin: {
        updateContext: (ctx, args) => {
            ctx.frm.push((ctx.join = { args, join: ' full join ' }));
        }
    },
    crossJoin: {
        updateContext: (ctx, args) => {
            ctx.frm.push((ctx.join = { args, join: ' cross join ' }));
        }
    },
    naturalJoin: {
        updateContext: (ctx, args) => {
            ctx.frm.push((ctx.join = { args, join: ' natural join ' }));
        }
    },
    naturalLeftJoin: {
        updateContext: (ctx, args) => {
            ctx.frm.push((ctx.join = { args, join: ' natural left join ' }));
        }
    },
    naturalRightJoin: {
        updateContext: (ctx, args) => {
            ctx.frm.push((ctx.join = { args, join: ' natural right join ' }));
        }
    },
    naturalFullJoin: {
        updateContext: (ctx, args) => {
            ctx.frm.push((ctx.join = { args, join: ' natural full join ' }));
        }
    },
    on: {
        updateContext: (ctx, args) => {
            const { join } = ctx;
            if (join.on) {
                join.on.push(args);
            } else {
                ctx.target = join.on = [args];
            }
        }
    },
    using: {
        updateContext: (ctx, args) => {
            const { join } = ctx;
            if (join.using) {
                join.using.push(args);
            } else {
                join.using = [args];
            }
        }
    },
    delete: {
        // getter: true,
        updateContext: ctx => {
            ctx.type = 'delete';
        }
    },
    insert: {
        updateContext: (ctx, args) => {
            ctx.type = 'insert';
            ctx.insert = args;
        }
    },
    set: {
        updateContext: (ctx, args) => {
            ctx.type = 'update';
            ctx.set.push(args);
        }
    },
    express: {
        updateContext: (ctx, args, count) => {
            if (count.id === 0) {
                count.id++;
                ctx.frm.push((ctx.join = { type: 'from', args, join: ', ' }));
            } else if (count.id === 1) {
                count.id++;
                ctx.whr.push(args);
            } else if (count.id === 2) {
                count.id++;
                ctx.ret.push(args);
            } else throw Error('Invalid express call')
        }
    }
};

var methods_1 = methods$1;

const { mapJoin: mapJoin$7 } = libUtil;

var values_array = (ctx, array) => {
  const keys = uniqueKeys(array);
  return {
    columns: columns(ctx, keys),
    values: values(ctx, array, keys)
  }
};

// gets unique keys in object array
const uniqueKeys = array => {
  const keys = {};
  for (const object of array) {
    for (const key in object) {
      keys[key] = true;
    }
  }
  return Object.keys(keys)
};

// gets column string from unique keys of object array
const columns = mapJoin$7((ctx, arg) => ctx.mapKey(arg));

// gets values string of object array
const values = (ctx, source, keys) => {
  let txt = 'values ';
  for (let i = 0; i < source.length; ++i) {
    if (i !== 0) txt += ', ';
    txt += '(';
    const object = source[i];
    for (let j = 0; j < keys.length; ++j) {
      if (j !== 0) txt += ', ';
      txt += value$1(ctx, object[keys[j]]);
    }
    txt += ')';
  }
  return txt
};

const value$1 = (ctx, arg) => {
  if (arg === undefined) return 'default'
  return ctx.build(arg)
};

const {
  isObject: isObject$5,
  buildCall: buildCall$7,
  mapJoin: mapJoin$6,
  objectMapJoin: objectMapJoin$4
} = libUtil;


var _with = ctx => {
  if (ctx.with.length === 0) return
  const txt = calls$3(ctx, ctx.with);
  return txt && `with ${ctx.recursive ? 'recursive ' : ''}${txt}`
};

const buildArg$4 = (ctx, arg) => {
  if (isObject$5(arg)) return buildObject$5(ctx, arg)
  throw Error('Invalid with argument:', arg)
};

const buildProperty$4 = (ctx, key, value) => {
  if (typeof value === 'function') {
    return `${ctx.mapKey(key)} ${ctx.build(value)}`
  }
  if (Array.isArray(value)) {
    const { columns, values } = values_array(ctx, value);
    return `${ctx.mapKey(key)}(${columns}) (${values})`
  }
  throw Error(`Error: Invalid .with argument`)
};

const buildObject$5 = objectMapJoin$4(buildProperty$4);
const calls$3 = mapJoin$6(buildCall$7(mapJoin$6(buildArg$4)));

const {
  isObject: isObject$4,
  buildCall: buildCall$6,
  mapJoin: mapJoin$5,
  objectMapJoin: objectMapJoin$3
} = libUtil;

const buildArg$3 = (ctx, arg) => {
  if (typeof arg === 'string') return arg
  if (isObject$4(arg)) return buildObject$4(ctx, arg)
  return ctx.build(arg)
};

const buildProperty$3 = (ctx, key, value) => {
  const expression = typeof value === 'string' ? value : ctx.build(value);
  return `${expression} ${ctx.mapKey(key)}`
};

const buildObject$4 = objectMapJoin$3(buildProperty$3);
var expressions$1 = mapJoin$5(buildCall$6(mapJoin$5(buildArg$3)));

var select$2 = ctx =>
  `select ${buildDistinct(ctx)}${expressions$1(ctx, ctx.ret) || '*'}`;

const buildDistinct = ctx =>
  ctx.distinct
    ? ctx.distinct.length
      ? // TODO: expressions shouldn't be aliasable here
        `distinct on (${expressions$1(ctx, ctx.distinct)})`
      : 'distinct'
    : '';

const {
  isTaggedTemplate: isTaggedTemplate$2,
  buildTaggedTemplate: buildTaggedTemplate$3,
  isObject: isObject$3,
  mapJoin: mapJoin$4,
  objectMapJoin: objectMapJoin$2
} = libUtil;

const buildCall$5 = callbackfn => (ctx, args) =>
  isTaggedTemplate$2(args)
    ? `(${buildTaggedTemplate$3(ctx, args)})`
    : callbackfn(ctx, args);

const buildArg$2 = (ctx, arg) =>
  isObject$3(arg) ? buildObject$3(ctx, arg) : ctx.build(arg);

const valuesList = mapJoin$4((ctx, arg) => ctx.build(arg));

const buildProperty$2 = (ctx, key, value) => {
  const name = ctx.mapKey(key);
  if (value === null) return `(${name} is null)`
  if (Array.isArray(value)) return `(${name} in (${valuesList(ctx, value)}))`
  return `(${name} = ${ctx.build(value)})`
};

const buildObject$3 = objectMapJoin$2(buildProperty$2, ' and ');
var conditions = mapJoin$4(buildCall$5(mapJoin$4(buildArg$2, ' and ')), ' and ');

const {
  isObject: isObject$2,
  buildCall: buildCall$4,
  mapJoin: mapJoin$3,
  objectMapJoin: objectMapJoin$1
} = libUtil;



var from_items = (ctx, items, start = 0, end = items.length) => {
  if (end > items.length) end = items.length;
  let txt = '';
  for (let i = start; i < end; ++i) {
    const item = items[i];
    if (i !== start) txt += item.join;
    txt += fromItem(ctx, item.args);
    if (item.on) txt += ` on ${conditions(ctx, item.on)}`;
    else if (item.using) txt += ` using (${using$1(ctx, item.using)})`;
  }
  return txt
};

const usingArg = (ctx, arg) => {
  if (typeof arg === 'string') return arg
  if (typeof arg === 'function') return ctx.build(arg)
  throw Error('Error: Invalid .using arg')
};
const using$1 = mapJoin$3(buildCall$4(mapJoin$3(usingArg)));

const fromArg = (ctx, arg) => {
  if (typeof arg === 'string') return arg
  if (typeof arg === 'function') return ctx.build(arg)
  if (isObject$2(arg)) return buildObject$2(ctx, arg)
  throw Error('Error: Invalid .from argument:', arg)
};

const buildProperty$1 = (ctx, key, value) => {
  if (typeof value === 'string') return `${value} ${ctx.mapKey(key)}`
  if (typeof value === 'function')
    return `${ctx.build(value)} ${ctx.mapKey(key)}`
  if (Array.isArray(value)) {
    const { columns, values } = values_array(ctx, value);
    return `(${values}) ${ctx.mapKey(key)}(${columns})`
  }
  throw Error('Error: Invalid .from argument')
};

const buildObject$2 = objectMapJoin$1(buildProperty$1);
const fromItem = buildCall$4(mapJoin$3(fromArg));

var from$2 = ctx => {
  const txt = from_items(ctx, ctx.frm);
  return txt && `from ${txt}`
};

var where$2 = ctx => {
  if (ctx.whr.length === 0) return
  const txt = conditions(ctx, ctx.whr);
  return txt && 'where ' + txt
};

const { isObject: isObject$1, buildCall: buildCall$3, mapJoin: mapJoin$2, mapJoinWrap } = libUtil;

var group$2 = ctx => {
  if (ctx.grp.length === 0) return
  const txt = calls$2(ctx, ctx.grp);
  return txt && `group by ${txt}`
};

const buildArg$1 = (ctx, arg) => {
  if (typeof arg === 'string') return arg
  if (typeof arg === 'function') return ctx.build(arg)
  if (Array.isArray(arg)) return buildArrayArg(ctx, arg)
  if (isObject$1(arg)) return buildObject$1(ctx, arg)
  throw Error('Invalid order by argument:', arg)
};

const buildArrayArg = mapJoinWrap(buildArg$1);

// postgres only
// clone of buildArg() without support for object args
const buildCubeOrRollupArg = (ctx, arg) => {
  if (typeof arg === 'string') return arg
  if (typeof arg === 'function') return ctx.build(arg)
  if (Array.isArray(arg)) return buildCubeOrRollupArrayArg(ctx, arg)
  throw Error('Invalid cube/rollup argument')
};

// postgres only
// clone of buildArrayArg() without support for object args
const buildCubeOrRollupArrayArg = mapJoinWrap(buildCubeOrRollupArg);

// postgres only
const buildObject$1 = (ctx, obj) => {
  const { type, args } = obj;
  if (type === 'rollup') {
    return `rollup ${buildCubeOrRollupArg(ctx, args)}`
  }
  if (type === 'cube') {
    return `cube ${buildCubeOrRollupArg(ctx, args)}`
  }
  if (type === 'grouping sets') {
    return `grouping sets ${buildArg$1(ctx, args)}`
  }
  throw Error('Invalid group by argument')
};

const calls$2 = mapJoin$2(buildCall$3(mapJoin$2(buildArg$1)));

var having$2 = ctx => {
  if (ctx.hav.length === 0) return
  const txt = conditions(ctx, ctx.hav);
  return txt && 'having ' + txt
};

var setop$2 = ctx => {
  if (ctx.setop.length === 0) return
  let txt = '';
  let first = true;
  const { setop } = ctx;
  for (let i = 0; i < setop.length; ++i) {
    const { type, args } = ctx.setop[i];
    for (let j = 0; j < args.length; ++j) {
      if (!first) {
        txt += ' ';
      } else {
        first = false;
      }
      txt += `${type} ${ctx.build(args[j])}`;
    }
  }
  return txt
};

const { isObject, buildCall: buildCall$2, mapJoin: mapJoin$1 } = libUtil;

var order$2 = ctx => {
  if (ctx.ord.length === 0) return
  const txt = calls$1(ctx, ctx.ord);
  return txt && `order by ${txt}`
};

const buildArg = (ctx, arg) => {
  if (typeof arg === 'string') return arg
  if (typeof arg === 'function') return ctx.build(arg)
  if (isObject(arg)) return buildObject(ctx, arg)
  throw Error('Invalid order by argument:', arg)
};

const buildObject = (ctx, obj) => {
  let txt = '';
  const { by, sort, using, nulls } = obj;
  // by
  if (typeof by === 'string') txt += by;
  else if (typeof by === 'function') txt += ctx.build(by);
  else throw Error('Invalid order by property "by"')
  // sort
  if (sort) {
    if (sort === 'desc') txt += ' desc';
    else if (sort === 'asc') txt += ' asc';
    else if (typeof sort === 'string') txt += ` using ${sort}`;
    else throw Error('Invalid order by property "sort"')
  } else if (using) {
    if (typeof using === 'string') txt += ` using ${using}`;
    else throw Error('Invalid order by property "using"')
  }
  // nulls
  if (nulls === undefined);
  else if (nulls === 'last') txt += ' nulls last';
  else if (nulls === 'first') txt += ' nulls first';
  else throw Error('Invalid order by property "nulls"')
  // return
  return txt
};

const calls$1 = mapJoin$1(buildCall$2(mapJoin$1(buildArg)));

const { isTaggedTemplate: isTaggedTemplate$1, buildTaggedTemplate: buildTaggedTemplate$2 } = libUtil;

var limit_offset = (ctx, args) => {
  if (isTaggedTemplate$1(args)) return buildTaggedTemplate$2(ctx, args)
  const arg = args[0];
  if (typeof arg === 'number') return ctx.parameterize(arg)
  if (typeof arg === 'function') return ctx.build(arg)
  throw Error('Error: Invalid limit/offset argument')
};

var limit$2 = ctx => ctx.limit && `limit ${limit_offset(ctx, ctx.limit)}`;

var offset$2 = ctx => ctx.offset && `offset ${limit_offset(ctx, ctx.offset)}`;

var _delete = ctx => {
  const txt = from_items(ctx, ctx.frm);
  return txt && `delete from ${txt}`
};

var returning$2 = ctx => {
  if (!ctx.ret) return
  const txt = expressions$1(ctx, ctx.ret);
  return txt && `returning ${txt}`
};

const { isTaggedTemplate, buildTaggedTemplate: buildTaggedTemplate$1 } = libUtil;



var insert$1 = ctx => {
  const table = from_items(ctx, ctx.frm);
  const values = buildCall$1(ctx, ctx.insert);
  return `insert into ${table}${values}`
};

const buildCall$1 = (ctx, args) => {
  if (isTaggedTemplate(args)) return ' ' + buildTaggedTemplate$1(ctx, args)
  if (args.length === 1 && args[0] === undefined) return ' default values'
  if (Array.isArray(args[0])) return buildValuesArray(ctx, args[0])
  if (typeof args[0] === 'function') return ' ' + ctx.build(args[0])
  return buildValuesArray(ctx, args)
};

const buildValuesArray = (ctx, array) => {
  const { values, columns } = values_array(ctx, array);
  return `(${columns}) ${values}`
};

var update$2 = ctx => {
  const txt = from_items(ctx, ctx.frm);
  return txt && `update ${txt}`
};

const { buildCall, mapJoin, objectMapJoin } = libUtil;

var set$2 = ctx => {
  if (!ctx.set) return
  const txt = calls(ctx, ctx.set);
  return txt && 'set ' + txt
};

const buildProperty = (ctx, key, value) =>
  `${ctx.mapKey(key)} = ${ctx.build(value)}`;

const calls = mapJoin(buildCall(mapJoin(objectMapJoin(buildProperty))));

var clauses$1 = {
  wth: _with,
  select: select$2,
  from: from$2,
  where: where$2,
  group: group$2,
  having: having$2,
  setop: setop$2,
  order: order$2,
  limit: limit$2,
  offset: offset$2,
  del: _delete,
  returning: returning$2,
  insert: insert$1,
  update: update$2,
  set: set$2
};

const {
    wth: wth$1,
    select: select$1,
    from: from$1,
    where: where$1,
    group: group$1,
    having: having$1,
    setop: setop$1,
    order: order$1,
    limit: limit$1,
    offset: offset$1,
    del: del$1,
    returning: returning$1,
    insert,
    update: update$1,
    set: set$1,
} = clauses$1;

const query$2 = (...clauses) => ctx => {
    let text = '';
    for (const clause of clauses) {
        const str = clause && clause(ctx);
        if (str) {
            if (text) text += ctx.separator;
            text += str;
        }
    }
    return { text, args: ctx.params, type: ctx.userType || ctx.type }
};

const queries$2 = {
    select: query$2(
        wth$1,
        select$1,
        from$1,
        where$1,
        group$1,
        having$1,
        setop$1,
        order$1,
        limit$1,
        offset$1
    ),
    update: query$2(wth$1, update$1, set$1, where$1, returning$1),
    delete: query$2(wth$1, del$1, where$1, returning$1),
    insert: query$2(wth$1, insert, returning$1)
};

var query_1$1 = { query: query$2, queries: queries$2 };

var common$1 = {
  conditions,
  expressions: expressions$1,
  fromItems: from_items,
  limitOffset: limit_offset,
  valuesArray: values_array
};

const { query: query$1, queries: queries$1 } = query_1$1;



var libSq = {
  methods: methods_1,
  query: query$1,
  queries: queries$1,
  clauses: clauses$1,
  common: common$1
};

const { methods, queries, query, clauses, common } = libSq;

const { fromItems, expressions } = common;
const {
  wth,
  from,
  where,
  group,
  having,
  setop,
  order,
  limit,
  offset,
  returning,
  set
} = clauses;

const postgresMethods = {
  distinctOn: {
    updateContext: (ctx, args) => {
      if (ctx.distinct) {
        ctx.distinct.push(args);
      } else {
        ctx.distinct = [args];
      }
    }
  }
};

// SELECT supports .distinctOn(...expressions)
const select = ctx => {
  let txt = 'select ';
  if (ctx.distinct) {
    txt += 'distinct ';
    if (ctx.distinct.length) {
      txt += `on (${expressions(ctx, ctx.distinct)}) `;
    }
  }
  txt += expressions(ctx, ctx.ret) || '*';
  return txt
};
// DELETE: first .from call is used in the DELETE clause
// subsequent .from calls are used in the USING clause
const del = ctx => {
  const txt = fromItems(ctx, ctx.frm, 0, 1);
  return txt && `delete from ${txt}`
};
const using = ctx => {
  const txt = fromItems(ctx, ctx.frm, 1);
  return txt && `using ${txt}`
};
// UPDATE: first .from call is used in the UPDATE clause
// subsequent .from calls are used in the FROM clause
const update = ctx => {
  const txt = fromItems(ctx, ctx.frm, 0, 1);
  return txt && `update ${txt}`
};
const updateFrom = ctx => {
  const txt = fromItems(ctx, ctx.frm, 1);
  return txt && `from ${txt}`
};

var query_1 = {
  methods: { ...methods, ...postgresMethods },
  queries: {
    ...queries,
    select: query(
      wth,
      select,
      from,
      where,
      group,
      having,
      setop,
      order,
      limit,
      offset
    ),
    delete: query(wth, del, using, where, returning),
    update: query(wth, update, set, updateFrom, where, returning)
  },
  properties: {
    rollup: {
      value: (...args) => {
        return {
          type: 'rollup',
          args
        }
      }
    },
    cube: {
      value: (...args) => {
        return {
          type: 'cube',
          args
        }
      }
    },
    groupingSets: {
      value: (...args) => {
        return {
          type: 'grouping sets',
          args
        }
      }
    }
  }
};

const { buildTaggedTemplate } = libUtil;

const dateToYYYYMMDD = d => [
    d.getFullYear(),
    ('0' + (d.getMonth() + 1)).slice(-2),
    ('0' + d.getDate()).slice(-2)
].join('-');

const build = (ctx, arg) => {
    // compiled expression string
    if (arg.exp) return arg.exp
    // tagged template argument
    if (arg.tag) return buildTaggedTemplate(ctx, arg.tag)
    // expression, subquery or fragment argument
    return ctx.build(arg.arg)
};

const unaryPre$1 = op => ({
    minArgs: 1,
    maxArgs: 1,
    build: (ctx, args) => `(${op} ${build(ctx, args[0])})`
});

const unaryPost$1 = op => ({
    minArgs: 1,
    maxArgs: 1,
    build: (ctx, args) => `(${build(ctx, args[0])} ${op})`
});

const unaryFunction$1 = op => ({
    minArgs: 1,
    maxArgs: 1,
    build: (ctx, args) => `${op}(${build(ctx, args[0])})`
});

const binary$1 = op => ({
    minArgs: 2,
    maxArgs: 2,
    build: (ctx, args) => `(${build(ctx, args[0])} ${op} ${build(ctx, args[1])})`
});

const dateBinary$1 = op => ({
    minArgs: 2,
    maxArgs: 2,
    build: (ctx, args) => {
        const inDate = args[1].arg;
        if (typeof inDate.getMonth === 'function') {
            args[1].arg = dateToYYYYMMDD(inDate);
        }
        return `date(${build(ctx, args[0])}, 'YYYY-MM-DD') ${op} ${build(ctx, args[1])}`
    }
});


const ternary$1 = (op1, op2) => ({
    minArgs: 3,
    maxArgs: 3,
    build: (ctx, args) =>
        `(${build(ctx, args[0])} ${op1} ${build(ctx, args[1])} ${op2} ${build(
            ctx,
            args[2]
        )})`
});

const nary$1 = op => ({
    minArgs: 1,
    maxArgs: Number.MAX_SAFE_INTEGER,
    build: (ctx, args) => {
        if (args.length === 1) return build(ctx, args[0])
        let txt = '(';
        for (let i = 0; i < args.length; ++i) {
            if (i !== 0) txt += ` ${op} `;
            txt += build(ctx, args[i]);
        }
        return txt + ')'
    }
});

const naryFunction$1 = fn => ({
    minArgs: 1,
    maxArgs: Number.MAX_SAFE_INTEGER,
    build: (ctx, args) => {
        let txt = `${fn}(`;
        for (let i = 0; i < args.length; ++i) {
            if (i !== 0) txt += `, `;
            txt += build(ctx, args[i]);
        }
        return txt + ')'
    }
});

const oneValue$1 = {
    minArgs: 1,
    maxArgs: 1,
    build: (ctx, args) => build(ctx, args[0])
};

const compositeValue$1 = {
    minArgs: 1,
    maxArgs: Number.MAX_SAFE_INTEGER,
    build: (ctx, args) => {
        if (args.length === 1) return build(ctx, args[0])
        let txt = '';
        for (let i = 0; i < args.length; ++i) {
            if (i !== 0) txt += ', ';
            txt += build(ctx, args[i]);
        }
        return args.length > 1 ? `(${txt})` : txt
    }
};

const buildValuesList = (ctx, values) => {
    if (values.length === 0) throw Error('Error: .in operation values list empty')
    let txt = '(';
    for (let i = 0; i < values.length; ++i) {
        if (i !== 0) txt += ', ';
        txt += ctx.build(values[i]);
    }
    return txt + ')'
};

const membership$1 = op => ({
    minArgs: 2,
    maxArgs: 2,
    build: (ctx, [arg1, arg2]) =>
        `(${build(ctx, arg1)} ${op} ${Array.isArray(arg2.arg)
            ? buildValuesList(ctx, arg2.arg)
            : build(ctx, arg2)
        })`
});

const quantifiedComparison$1 = op => ({
    minArgs: 2,
    maxArgs: 2,
    build: (ctx, args) => `(${build(ctx, args[0])} ${op}(${build(ctx, args[1])}))`
});

var util = {
    build,
    unaryFunction: unaryFunction$1,
    unaryPre: unaryPre$1,
    unaryPost: unaryPost$1,
    binary: binary$1,
    ternary: ternary$1,
    nary: nary$1,
    naryFunction: naryFunction$1,
    oneValue: oneValue$1,
    compositeValue: compositeValue$1,
    membership: membership$1,
    quantifiedComparison: quantifiedComparison$1,
    dateBinary: dateBinary$1
};

const {
    unaryPre,
    unaryPost,
    unaryFunction,
    binary,
    ternary,
    nary,
    naryFunction,
    oneValue,
    compositeValue,
    membership,
    quantifiedComparison,
    dateBinary
} = util;

// value
const value = {
    arg: compositeValue,
    row: compositeValue,
    unknown: oneValue,
    boolean: oneValue,
    number: oneValue,
    string: oneValue,
    array: oneValue,
    json: oneValue,
    table: oneValue
};

// boolean
const boolean = {
    // logical
    and: nary('and'),
    or: nary('or'),
    not: unaryFunction('not'),
    // comparison
    isTrue: unaryPost('is true'),
    isNotTrue: unaryPost('is not true'),
    isFalse: unaryPost('is false'),
    isNotFalse: unaryPost('is not false'),
    isUnknown: unaryPost('is unknown'),
    isNotUnknown: unaryPost('is not unknown')
};

// comparison
const comparison = {
    // binary comparison
    eq: binary('='),
    neq: binary('<>'),
    lt: binary('<'),
    gt: binary('>'),
    lte: binary('<='),
    gte: binary('>='),
    // misc
    between: ternary('between', 'and'),
    isDistinctFrom: binary('is distinct from'),
    isNotDistinctFrom: binary('is not distinct from'),
    isNull: unaryPost('is null'),
    isNotNull: unaryPost('is not null'),
    in: membership('in'),
    notIn: membership('not in'),
    // quantified any
    eqAny: quantifiedComparison('= any'),
    neqAny: quantifiedComparison('<> any'),
    ltAny: quantifiedComparison('< any'),
    gtAny: quantifiedComparison('> any'),
    lteAny: quantifiedComparison('<= any'),
    gteAny: quantifiedComparison('>= any'),
    // quantified all
    eqAll: quantifiedComparison('= all'),
    neqAll: quantifiedComparison('<> all'),
    ltAll: quantifiedComparison('< all'),
    gtAll: quantifiedComparison('> all'),
    lteAll: quantifiedComparison('<= all'),
    gteAll: quantifiedComparison('>= all')
};

// dates
const dateComparison = {
    // dateEq: dateBinary('='),
    // dateNeq: dateBinary('<>'),
    dateLt: dateBinary('<'),
    dateGt: dateBinary('>'),
    dateLte: dateBinary('<='),
    dateGte: dateBinary('>=')
};

// math
const math = {
    add: binary('+'),
    sub: binary('-'),
    mul: binary('*'),
    div: binary('/'),
    mod: binary('%'),
    exp: binary('%'),
    sqrt: unaryPre('|/'),
    cbrt: unaryPre('||/'),
    fact: unaryPre('!!'),
    abs: unaryFunction('abs')
};

// string
const string = {
    like: binary('like'),
    notLike: binary('not like')
};

const array = {
    unnest: naryFunction('unnest')
};

var libExpression = {
    ...value,
    ...boolean,
    ...comparison,
    ...math,
    ...array,
    ...dateComparison,
    ...string
};

var expression = { expressions: libExpression };

// parameterizes given argument, function should be attached to ctx
function parameterize$1(arg) {
    if (arg === undefined) throw Error('Error: parameter is undefined')
    return `$${this.params.push(arg)}`
}

/** Escapes an argument for use in UNPARAMETERIZED queries. NOT SAFE AT ALL. */
const escape$1 = arg => {
    if (arg === undefined) throw Error('Error: parameter is undefined')
    if (arg === null) return 'null'
    if (typeof arg === 'string') return escapeLiteral(arg)
    if (typeof arg === 'number') return '' + arg
    if (typeof arg === 'boolean') return '' + arg
    if (typeof arg === 'object') {
        if (Array.isArray(arg)) {
            return `array[${arg.map(e => escape$1(e)).join(', ')}]`
        } else {
            return escapeLiteral(JSON.stringify(arg))
        }
    }
    throw Error(`Invalid argument SQL argument of type '${typeof arg}'`, arg)
};

// from https://github.com/brianc/node-postgres/blob/eb076db5d47a29c19d3212feac26cd7b6d257a95/lib/client.js#L351
const escapeLiteral = str => {
    let hasBackslash = false;
    let escaped = "'";
    for (let i = 0; i < str.length; i++) {
        const c = str[i];
        if (c === "'") {
            escaped += c + c;
        } else if (c === '\\') {
            escaped += c + c;
            hasBackslash = true;
        } else {
            escaped += c;
        }
    }
    escaped += "'";
    if (hasBackslash === true) {
        escaped = ' E' + escaped;
    }
    return escaped
};

var parameterize_1 = {
    parameterize: parameterize$1,
    escape: escape$1
};

const { parameterize, escape } = parameterize_1;

var dialectPostgres = {
  query: query_1,
  expression,
  parameterize,
  escape
};

const a$1 = libCore({ dialect: dialectPostgres });
a$1.from = undefined;
var src = a$1;

var imageExtensions = [
	"ase",
	"art",
	"bmp",
	"blp",
	"cd5",
	"cit",
	"cpt",
	"cr2",
	"cut",
	"dds",
	"dib",
	"djvu",
	"egt",
	"exif",
	"gif",
	"gpl",
	"grf",
	"icns",
	"heic",
	"ico",
	"iff",
	"jng",
	"jpeg",
	"jpg",
	"jfif",
	"jp2",
	"jps",
	"lbm",
	"max",
	"miff",
	"mng",
	"msp",
	"nitf",
	"ota",
	"pbm",
	"pc1",
	"pc2",
	"pc3",
	"pcf",
	"pcx",
	"pdn",
	"pgm",
	"PI1",
	"PI2",
	"PI3",
	"pict",
	"pct",
	"pnm",
	"pns",
	"ppm",
	"psb",
	"psd",
	"pdd",
	"psp",
	"px",
	"pxm",
	"pxr",
	"qfx",
	"raw",
	"rle",
	"sct",
	"sgi",
	"rgb",
	"int",
	"bw",
	"tga",
	"tiff",
	"tif",
	"vtf",
	"xbm",
	"xcf",
	"xpm",
	"3dv",
	"amf",
	"ai",
	"awg",
	"cgm",
	"cdr",
	"cmx",
	"dxf",
	"e2d",
	"egt",
	"eps",
	"fs",
	"gbr",
	"odg",
	"svg",
	"stl",
	"vrml",
	"x3d",
	"sxd",
	"v2d",
	"vnd",
	"wmf",
	"emf",
	"art",
	"xar",
	"png",
	"webp",
	"jxr",
	"hdp",
	"wdp",
	"cur",
	"ecw",
	"iff",
	"lbm",
	"liff",
	"nrrd",
	"pam",
	"pcx",
	"pgf",
	"sgi",
	"rgb",
	"rgba",
	"bw",
	"int",
	"inta",
	"sid",
	"ras",
	"sun",
	"tga"
];

var videoExtensions = [
	"3g2",
	"3gp",
	"aaf",
	"asf",
	"avchd",
	"avi",
	"drc",
	"flv",
	"m2v",
	"m4p",
	"m4v",
	"mkv",
	"mng",
	"mov",
	"mp2",
	"mp4",
	"mpe",
	"mpeg",
	"mpg",
	"mpv",
	"mxf",
	"nsv",
	"ogg",
	"ogv",
	"qt",
	"rm",
	"rmvb",
	"roq",
	"svi",
	"vob",
	"webm",
	"wmv",
	"yuv"
];

function dbFactory(globals) {
    const g = globals || _g;
    const { tokenPost, tokenPostAttachment } = authFactory(g);
    let _listenerIndex = 0;
    const _listeners = {};
    function _runListeners(...params) {
        for (const cb of Object.values(_listeners)) {
            cb(...params);
        }
    }
    const dbEventListener = (callback) => {
        const currKey = '' + _listenerIndex++;
        _listeners[currKey] = callback;
        return () => {
            delete _listeners[currKey];
        };
    };
    const allCallback = async (trx, tableName, userAssociatedRecordsOnly) => {
        trx.count = "all";
        trx.tableName = tableName;
        if (userAssociatedRecordsOnly)
            trx.userAssociatedRecordsOnly = userAssociatedRecordsOnly;
        _runListeners(DB_STATUS.PENDING, trx.type, EXECUTE_COUNT.ALL, tableName !== "untable" ? tableName : null);
        try {
            const res = await tokenPost(POST_TYPES.EASY_QB, trx);
            if (res.success) {
                g.analyticsEnabled && g.analyticsEventsToTrack.db_all && g.analyticsEvent('db_all', { tableName: tableName !== "untable" ? tableName : undefined, type: trx.type });
                _runListeners(DB_STATUS.SUCCESS, trx.type, EXECUTE_COUNT.ALL, tableName !== "untable" ? tableName : null, res.data);
                return res.data;
            }
            else {
                _runListeners(DB_STATUS.ERROR, trx.type, EXECUTE_COUNT.ALL, tableName !== "untable" ? tableName : null);
                return res;
            }
        }
        catch (error) {
            console.warn(error);
            _runListeners(DB_STATUS.ERROR, trx.type, EXECUTE_COUNT.ALL, tableName !== "untable" ? tableName : null);
            return [];
        }
    };
    const oneCallback = async (trx, tableName, userAssociatedRecordsOnly) => {
        trx.count = "one";
        trx.tableName = tableName;
        if (userAssociatedRecordsOnly)
            trx.userAssociatedRecordsOnly = userAssociatedRecordsOnly;
        _runListeners(DB_STATUS.PENDING, trx.type, EXECUTE_COUNT.ONE, tableName !== "untable" ? tableName : null);
        try {
            const res = await tokenPost(POST_TYPES.EASY_QB, trx);
            if (res.success) {
                g.analyticsEnabled && g.analyticsEventsToTrack.db_one && g.analyticsEvent('db_one', { tableName: tableName !== "untable" ? tableName : undefined, type: trx.type });
                _runListeners(DB_STATUS.SUCCESS, trx.type, EXECUTE_COUNT.ONE, tableName !== "untable" ? tableName : null, res.data);
                return res.data;
            }
            else {
                _runListeners(DB_STATUS.ERROR, trx.type, EXECUTE_COUNT.ONE, tableName !== "untable" ? tableName : null);
                return res;
            }
        }
        catch (error) {
            console.warn(error);
            _runListeners(DB_STATUS.ERROR, trx.type, EXECUTE_COUNT.ONE, tableName !== "untable" ? tableName : null);
            return {};
        }
    };
    const db = (tableName, userAssociatedRecordsOnly) => {
        if (tableName && typeof tableName === "string") {
            return src({ allCallback, oneCallback, userAssociatedRecordsOnly, tableName: tableName.toUpperCase() })(tableName.replace(/[^0-9a-zA-Z]/g, '_').toUpperCase());
        }
        else {
            return src({ allCallback, oneCallback, userAssociatedRecordsOnly, tableName: "untable" })("untable");
        }
    };
    const _setAttachment = async ({ recordKey, columnName, attachment, tableName, type }) => {
        const ext = attachment.name.split(".").pop().toLowerCase();
        // Similar pattern as db() naming
        let fixedTableName;
        if (tableName && typeof tableName === "string") {
            fixedTableName = tableName.toUpperCase();
        }
        else {
            fixedTableName = "untable";
        }
        if (type === "image" && !imageExtensions.includes(ext)) {
            return {
                success: false,
                message: "Image files must have a proper image extension in the file name"
            };
        }
        if (type === "video" && !videoExtensions.includes(ext)) {
            return {
                success: false,
                message: "Video files must have a proper video extension in the file name"
            };
        }
        const formData = new FormData();
        formData.append("file", attachment);
        formData.append("name", attachment.name);
        const customHeaders = {
            'Eb-upload-type': type,
            'Eb-column-name': columnName,
            'Eb-record-id': recordKey,
            'Eb-table-name': fixedTableName
        };
        try {
            const res = await tokenPostAttachment(formData, customHeaders);
            if (res.success) {
                g.analyticsEnabled && g.analyticsEventsToTrack.db_one && g.analyticsEvent('db_one', { tableName: fixedTableName !== "untable" ? fixedTableName : undefined, type: "update" });
                _runListeners(DB_STATUS.SUCCESS, "update", EXECUTE_COUNT.ONE, fixedTableName !== "untable" ? fixedTableName : null, res.data);
            }
            else {
                _runListeners(DB_STATUS.ERROR, "update", EXECUTE_COUNT.ONE, fixedTableName !== "untable" ? fixedTableName : null);
            }
            return {
                message: res.data,
                success: res.success
            };
        }
        catch (error) {
            console.warn(error);
            _runListeners(DB_STATUS.ERROR, "update", EXECUTE_COUNT.ONE, fixedTableName !== "untable" ? fixedTableName : null);
            return {
                message: "",
                success: false,
            };
        }
    };
    const setImage = async (recordKey, columnName, image, tableName) => _setAttachment({
        recordKey,
        columnName,
        tableName,
        attachment: image,
        type: "image"
    });
    const setVideo = async (recordKey, columnName, video, tableName) => _setAttachment({
        recordKey,
        columnName,
        tableName,
        attachment: video,
        type: "video"
    });
    const setFile = async (recordKey, columnName, file, tableName) => _setAttachment({
        recordKey,
        columnName,
        tableName,
        attachment: file,
        type: "file"
    });
    return {
        db,
        dbEventListener,
        e: src().e,
        setImage,
        setFile,
        setVideo
    };
}

function t(){const t=this[d],e=t.target;let o,r,n;for(e.reverse(),o=0,r=e.length;o<r;o++)if((n=e[o])&&"object"==typeof n){const i=n[d];i&&(i.ownKey=o);}var s=[new O(h,[],void 0,void 0,this)];return j(t,s),this}function e(t){const e=this[d],o=e.target;let r,n,s;for(o.sort(t),r=0,n=o.length;r<n;r++)if((s=o[r])&&"object"==typeof s){const i=s[d];i&&(i.ownKey=r);}return t=[new O(a,[],void 0,void 0,this)],j(e,t),this}function o(t,n,s){const i=this[d],h=i.target,a=[],e=h.length,l=h.slice(0);if(n=void 0===n?0:n<0?Math.max(e+n,0):Math.min(n,e),s=void 0===s?e:s<0?Math.max(e+s,0):Math.min(s,e),n<e&&n<s){h.fill(t,n,s);let r;for(let t=n,e,o;t<s;t++)e=h[t],h[t]=m(e,t,i),t in l?(o=l[t],o&&"object"==typeof o&&(r=o[d],r&&(o=r.detach())),a.push(new O(v,[t],h[t],o,this))):a.push(new O(w,[t],h[t],void 0,this));j(i,a);}return this}function r(n,t,e){const s=this[d],i=s.target,o=i.length;n=n<0?Math.max(o+n,0):n,t=void 0===t?0:t<0?Math.max(o+t,0):Math.min(t,o),e=void 0===e?o:e<0?Math.max(o+e,0):Math.min(e,o);var h=Math.min(e-t,o-n);if(n<o&&n!==t&&0<h){const a=i.slice(0),l=[];i.copyWithin(n,t,e);for(let t=n,e,o,r;t<n+h;t++)e=i[t],e&&"object"==typeof e&&(e=m(e,t,s),i[t]=e),o=a[t],o&&"object"==typeof o&&(r=o[d],r&&(o=r.detach())),"object"!=typeof e&&e===o||l.push(new O(v,[t],e,o,this));j(s,l);}return this}const w="insert",v="update",g="delete",h="reverse",a="shuffle",d=Symbol.for("object-observer-meta-key-0"),n={async:1},s={observe:{value:function(e,t){if("function"!=typeof e)throw new Error(`observer MUST be a function, got '${e}'`);const o=this[d].observers;o.some(t=>t[0]===e)?console.warn("observer may be bound to an observable only once; will NOT rebind"):o.push([e,(t=>{if(!t||"object"!=typeof t)return null;const e={},o=[];for(var[r,n]of Object.entries(t))if("path"===r){if("string"!=typeof n||""===n)throw new Error('"path" option, if/when provided, MUST be a non-empty string');e[r]=n;}else if("pathsOf"===r){if(t.path)throw new Error('"pathsOf" option MAY NOT be specified together with "path" option');if("string"!=typeof n)throw new Error('"pathsOf" option, if/when provided, MUST be a string (MAY be empty)');e[r]=t.pathsOf.split(".").filter(Boolean);}else if("pathsFrom"===r){if(t.path||t.pathsOf)throw new Error('"pathsFrom" option MAY NOT be specified together with "path"/"pathsOf" option/s');if("string"!=typeof n||""===n)throw new Error('"pathsFrom" option, if/when provided, MUST be a non-empty string');e[r]=n;}else o.push(r);if(o.length)throw new Error(`'${o.join(", ")}' is/are not a valid observer option/s`);return e})(t)]);}},unobserve:{value:function(){const o=this[d].observers;let r=o.length;if(r){let e=arguments.length;if(e)for(;e--;){let t=r;for(;t--;)o[t][0]===arguments[e]&&(o.splice(t,1),r--);}else o.splice(0);}}}},i=(t,e)=>{const o=Object.defineProperties({},s);o[d]=e;for(const r in t)o[r]=m(t[r],r,e);return o},l=(e,o)=>{var r=e.length;const n=Object.defineProperties(new Array(r),s);n[d]=o;for(let t=0;t<r;t++)n[t]=m(e[t],t,o);return n},f=(t,e)=>(Object.defineProperties(t,s),t[d]=e,t),c=(t,e)=>{if(!t)return e;let o=e;if(t.path){const r=t.path;o=e.filter(t=>t.path.join(".")===r);}else if(t.pathsOf){const n=t.pathsOf,s=n.join(".");o=e.filter(t=>(t.path.length===n.length+1||t.path.length===n.length&&(t.type===h||t.type===a))&&t.path.join(".").startsWith(s));}else if(t.pathsFrom){const i=t.pathsFrom;o=e.filter(t=>t.path.join(".").startsWith(i));}return o},p=(e,o)=>{try{e(o);}catch(t){console.error(`failed to notify listener ${e} with `+o,t);}},u=function(){var t,e,o=this.batches;this.batches=null;for([t,e]of o)p(t,e);},j=(t,e)=>{let o=t,r,n,s,i,h;var a=e.length;do{for(r=o.observers,h=r.length;h--;)if([n,s]=r[h],(i=c(s,e)).length)if(o.options.async){o.batches||(o.batches=[],queueMicrotask(u.bind(o)));let t;for(const l of o.batches)if(l[0]===n){t=l;break}t||(t=[n,[]],o.batches.push(t)),Array.prototype.push.apply(t[1],i);}else p(n,i);if(o.parent){const f=new Array(a);for(let t=0;t<a;t++)f[t]={...e[t]},f[t].path=[o.ownKey,...f[t].path];e=f,o=o.parent;}else o=null;}while(o)},m=(t,e,o)=>t&&"object"==typeof t?Array.isArray(t)?new A({target:t,ownKey:e,parent:o}).proxy:ArrayBuffer.isView(t)?new K({target:t,ownKey:e,parent:o}).proxy:t instanceof Date?t:new M({target:t,ownKey:e,parent:o}).proxy:t,y={pop:function(){const t=this[d],e=t.target,o=e.length-1;let r=e.pop();if(r&&"object"==typeof r){const s=r[d];s&&(r=s.detach());}var n=[new O(g,[o],void 0,r,this)];return j(t,n),r},push:function(){const e=this[d],o=e.target,r=arguments.length,n=new Array(r),s=o.length;for(let t=0;t<r;t++)n[t]=m(arguments[t],s+t,e);var t=Reflect.apply(o.push,o,n);const i=[];for(let t=s,e=o.length;t<e;t++)i[t-s]=new O(w,[t],o[t],void 0,this);return j(e,i),t},shift:function(){const t=this[d],e=t.target;let o,r,n,s,i;for(o=e.shift(),o&&"object"==typeof o&&(i=o[d],i&&(o=i.detach())),r=0,n=e.length;r<n;r++)(s=e[r])&&"object"==typeof s&&(i=s[d],i&&(i.ownKey=r));var h=[new O(g,[0],void 0,o,this)];return j(t,h),o},unshift:function(){const e=this[d],r=e.target,o=arguments.length,n=new Array(o);for(let t=0;t<o;t++)n[t]=m(arguments[t],t,e);var t=Reflect.apply(r.unshift,r,n);for(let t=0,e=r.length,o;t<e;t++)if((o=r[t])&&"object"==typeof o){const h=o[d];h&&(h.ownKey=t);}var s=n.length;const i=new Array(s);for(let t=0;t<s;t++)i[t]=new O(w,[t],r[t],void 0,this);return j(e,i),t},reverse:t,sort:e,fill:o,copyWithin:r,splice:function(){const e=this[d],o=e.target,r=arguments.length,n=new Array(r),t=o.length;for(let t=0;t<r;t++)n[t]=m(arguments[t],t,e);const s=0===r?0:n[0]<0?t+n[0]:n[0],i=r<2?t-s:n[1],h=Math.max(r-2,0),a=Reflect.apply(o.splice,o,n),l=o.length;let f;for(let t=0,e;t<l;t++)(e=o[t])&&"object"==typeof e&&(f=e[d],f&&(f.ownKey=t));let c,p,u;for(c=0,p=a.length;c<p;c++)(u=a[c])&&"object"==typeof u&&(f=u[d],f&&(a[c]=f.detach()));const y=[];let b;for(b=0;b<i;b++)b<h?y.push(new O(v,[s+b],o[s+b],a[b],this)):y.push(new O(g,[s+b],void 0,a[b],this));for(;b<h;b++)y.push(new O(w,[s+b],o[s+b],void 0,this));return j(e,y),a}},b={reverse:t,sort:e,fill:o,copyWithin:r,set:function(t,e){const o=this[d],r=o.target,n=t.length,s=r.slice(0);e=e||0,r.set(t,e);const i=new Array(n);for(let t=e;t<n+e;t++)i[t-e]=new O(v,[t],r[t],s[t],this);j(o,i);}};class O{constructor(t,e,o,r,n){this.type=t,this.path=e,this.value=o,this.oldValue=r,this.object=n;}}class x{constructor(t,e){var{target:o,parent:r,ownKey:n}=t;r&&void 0!==n?(this.parent=r,this.ownKey=n):(this.parent=null,this.ownKey=null);o=e(o,this);this.observers=[],this.revocable=Proxy.revocable(o,this),this.proxy=this.revocable.proxy,this.target=o,this.options=this.processOptions(t.options);}processOptions(t){if(t){if("object"!=typeof t)throw new Error(`Observable options if/when provided, MAY only be an object, got '${t}'`);const e=Object.keys(t).filter(t=>!(t in n));if(e.length)throw new Error(`'${e.join(", ")}' is/are not a valid Observable option/s`);return Object.assign({},t)}return {}}detach(){return this.parent=null,this.target}set(t,e,o){let r=t[e];if(o!==r){o=m(o,e,this);if(t[e]=o,r&&"object"==typeof r){const n=r[d];n&&(r=n.detach());}o=void 0===r?[new O(w,[e],o,void 0,this.proxy)]:[new O(v,[e],o,r,this.proxy)];j(this,o);}return !0}deleteProperty(t,e){let o=t[e];if(delete t[e],o&&"object"==typeof o){const r=o[d];r&&(o=r.detach());}e=[new O(g,[e],void 0,o,this.proxy)];return j(this,e),!0}}class M extends x{constructor(t){super(t,i);}}class A extends x{constructor(t){super(t,l);}get(t,e){return y[e]||t[e]}}class K extends x{constructor(t){super(t,f);}get(t,e){return b[e]||t[e]}}const E=Object.freeze({from:(t,e)=>{if(t&&"object"==typeof t){if(t[d])return t;if(Array.isArray(t))return new A({target:t,ownKey:null,parent:null,options:e}).proxy;if(ArrayBuffer.isView(t))return new K({target:t,ownKey:null,parent:null,options:e}).proxy;if(t instanceof Date)throw new Error(t+" found to be one of a non-observable types");return new M({target:t,ownKey:null,parent:null,options:e}).proxy}throw new Error("observable MAY ONLY be created from a non-null object")},isObservable:t=>!(!t||!t[d])});

function _catch(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }

  if (result && result.then) {
    return result.then(void 0, recover);
  }

  return result;
}

var cache = require("./cache");

var _isFrameInitialized = true;
var _frameConfiguration = {
  offset: 0,
  limit: 0
};

var _effect = function _effect() {
  return function () {};
};

var _signInCallback;

var _observedChangeStack = [];

var _recordIdMap = new WeakMap();

var _proxyRecordMap = new WeakMap();

var EasybaseProvider = function EasybaseProvider(_ref) {
  var children = _ref.children,
      ebconfig = _ref.ebconfig,
      options = _ref.options;

  if (typeof ebconfig !== 'object' || ebconfig === null || ebconfig === undefined) {
    console.error("No ebconfig object passed. do `import ebconfig from \"./ebconfig.js\"` and pass it to the Easybase provider");
    return React__default["default"].createElement(React.Fragment, null, children);
  } else if (!ebconfig.integration) {
    console.error("Invalid ebconfig object passed. Download ebconfig.json from Easybase.io and try again.");
    return React__default["default"].createElement(React.Fragment, null, children);
  }

  var _useState = React.useState(false),
      mounted = _useState[0],
      setMounted = _useState[1];

  var _useState2 = React.useState(false),
      isSyncing = _useState2[0],
      setIsSyncing = _useState2[1];

  var _useState3 = React.useState(false),
      userSignedIn = _useState3[0],
      setUserSignedIn = _useState3[1];

  var _useState4 = React.useState([]),
      _frame = _useState4[0],
      _setFrame = _useState4[1];

  var _useState5 = React.useState({
    observe: function observe() {},
    unobserve: function unobserve() {}
  }),
      _observableFrame = _useState5[0],
      _setObservableFrame = _useState5[1];

  var _ranSignInCallback = React.useRef(false); // TODO: useRef vs useState({})


  var g = React.useRef(gFactory({
    ebconfig: ebconfig,
    options: options
  })).current;
  var _useRef$current = React.useRef(authFactory(g)).current,
      initAuth = _useRef$current.initAuth,
      tokenPost = _useRef$current.tokenPost,
      tokenPostAttachment = _useRef$current.tokenPostAttachment,
      signUp = _useRef$current.signUp,
      setUserAttribute = _useRef$current.setUserAttribute,
      getUserAttributes = _useRef$current.getUserAttributes,
      resetUserPassword = _useRef$current.resetUserPassword,
      signIn = _useRef$current.signIn,
      signOut = _useRef$current.signOut,
      forgotPassword = _useRef$current.forgotPassword,
      forgotPasswordConfirm = _useRef$current.forgotPasswordConfirm,
      userID = _useRef$current.userID;
  var log = React.useRef(utilsFactory(g)).current.log;
  var _useRef$current2 = React.useRef(tableFactory(g)).current,
      Query = _useRef$current2.Query,
      fullTableSize = _useRef$current2.fullTableSize,
      tableTypes = _useRef$current2.tableTypes;
  var _useRef$current3 = React.useRef(dbFactory(g)).current,
      db = _useRef$current3.db,
      dbEventListener = _useRef$current3.dbEventListener,
      e = _useRef$current3.e,
      setFile = _useRef$current3.setFile,
      setImage = _useRef$current3.setImage,
      setVideo = _useRef$current3.setVideo;
  React.useEffect(function () {
    var mount = function mount() {
      try {
        var _temp10 = function _temp10() {
          var _temp7 = function () {
            if (g.ebconfig.tt && g.ebconfig.integration.split("-")[0].toUpperCase() !== "PROJECT") {
              var t1 = Date.now();
              log("mounting...");
              return Promise.resolve(initAuth()).then(function () {
                return Promise.resolve(tokenPost(POST_TYPES$1.VALID_TOKEN)).then(function (res) {
                  var elapsed = Date.now() - t1;

                  if (res.success) {
                    log("Valid auth initiation in " + elapsed + "ms");
                    setMounted(true);
                  }
                });
              });
            } else {
              g.mounted = true; // Bypass initAuth()

              var cookieName = g.ebconfig.integration.slice(-10);
              return Promise.resolve(cache.getCacheTokens(cookieName)).then(function (_ref2) {
                var cacheToken = _ref2.cacheToken,
                    cacheRefreshToken = _ref2.cacheRefreshToken,
                    cacheSession = _ref2.cacheSession;

                function _temp6() {
                  setMounted(true);
                }

                var _temp5 = function () {
                  if (cacheRefreshToken) {
                    g.token = cacheToken;
                    g.refreshToken = cacheRefreshToken;
                    g.session = +cacheSession;
                    var fallbackMount = setTimeout(function () {
                      setMounted(true);
                    }, 2500);
                    return Promise.resolve(Promise.all([tokenPost(POST_TYPES$1.REQUEST_TOKEN, {
                      refreshToken: g.refreshToken,
                      token: g.token,
                      getUserID: true
                    }), Promise.resolve().then(function () { return require('./sha256-af354191.js'); }).then(function (n) { return n.sha256; }), Promise.resolve().then(function () { return require('./index-3188f313.js'); })])).then(function (_ref3) {
                      var refreshTokenRes = _ref3[0],
                          hash = _ref3[1].hash,
                          fromUtf8 = _ref3[2].fromUtf8;

                      var _temp4 = function () {
                        if (refreshTokenRes.success) {
                          clearTimeout(fallbackMount);
                          g.token = refreshTokenRes.data.token;
                          g.userID = refreshTokenRes.data.userID;

                          if (g.analyticsEnabled && g.analyticsEventsToTrack.login) {
                            var hashOut = hash(fromUtf8(g.GA_USER_ID_SALT + refreshTokenRes.data.userID));
                            var hexHash = Array.prototype.map.call(hashOut, function (x) {
                              return ('00' + x.toString(16)).slice(-2);
                            }).join('');
                            g.analyticsIdentify(hexHash);
                            g.analyticsEvent('login', {
                              method: "Easybase"
                            });
                          }

                          return Promise.resolve(cache.setCacheTokens(g, cookieName)).then(function () {
                            setUserSignedIn(true);
                          });
                        } else {
                          cache.clearCacheTokens(cookieName);
                        }
                      }();

                      if (_temp4 && _temp4.then) return _temp4.then(function () {});
                    });
                  }
                }();

                return _temp5 && _temp5.then ? _temp5.then(_temp6) : _temp6(_temp5);
              });
            }
          }();

          if (_temp7 && _temp7.then) return _temp7.then(function () {});
        };

        // eslint-disable-next-line dot-notation
        var isIE = typeof document !== 'undefined' && !!document['documentMode'];

        if (isIE) {
          console.error("EASYBASE â€” easybase-react does not support Internet Explorer. Please use a different browser.");
        }

        g.instance = typeof navigator !== 'undefined' && navigator.product === 'ReactNative' ? "React Native" : "React";

        var _temp11 = function () {
          if (options != null && options.googleAnalyticsId) {
            var _temp12 = function () {
              if (options.googleAnalyticsId.startsWith("G-")) {
                var _temp13 = function () {
                  if (g.instance === "React") {
                    return Promise.resolve(Promise.resolve().then(function () { return require('./ga-4-react.esm-5f23ef14.js'); })).then(function (_ref4) {
                      var GA4React = _ref4.GA4React;
                      var ga4ReactLoader = new GA4React(options.googleAnalyticsId);

                      var _temp = _catch(function () {
                        return Promise.resolve(ga4ReactLoader.initialize()).then(function (ga4React) {
                          g.analyticsEvent = function (eventTitle, params) {
                            return ga4React.gtag('event', eventTitle, params);
                          };

                          g.analyticsIdentify = function (hashedUserId) {
                            return ga4React.gtag('config', options.googleAnalyticsId, {
                              user_id: hashedUserId
                            });
                          };

                          g.analyticsEnabled = true;

                          if (window.location.hash) {
                            // Using hash router - https://github.com/unrealmanu/ga-4-react/issues/15
                            window.onhashchange = function () {
                              ga4React.pageview(window.location.hash);
                            };
                          }
                        });
                      }, function (error) {
                        log("Analytics initialization error: ", error);
                      });

                      if (_temp && _temp.then) return _temp.then(function () {});
                    });
                  } else if (g.instance === "React Native") {
                    if (options.googleAnalyticsSecret) {
                      var genUUID = function genUUID() {
                        // https://www.w3resource.com/javascript-exercises/javascript-math-exercise-23.php
                        var dt = new Date().getTime();
                        var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                          var r = (dt + Math.random() * 16) % 16 | 0;
                          dt = Math.floor(dt / 16);
                          return (c === 'x' ? r : r & 0x3 | 0x8).toString(16);
                        });
                        return uuid;
                      };

                      var _userIdHash;

                      var _mockDeviceId = genUUID(); // Mocking a 'pageview'


                      fetch("https://www.google-analytics.com/mp/collect?measurement_id=" + options.googleAnalyticsId + "&api_secret=" + options.googleAnalyticsSecret, {
                        method: "POST",
                        body: JSON.stringify({
                          client_id: _mockDeviceId,
                          events: [{
                            name: 'select_content'
                          }]
                        })
                      });

                      g.analyticsEvent = function (eventTitle, params) {
                        return fetch("https://www.google-analytics.com/mp/collect?measurement_id=" + options.googleAnalyticsId + "&api_secret=" + options.googleAnalyticsSecret, {
                          method: "POST",
                          body: JSON.stringify({
                            client_id: _mockDeviceId,
                            user_id: _userIdHash,
                            events: [{
                              name: eventTitle,
                              params: params
                            }]
                          })
                        });
                      };

                      g.analyticsIdentify = function (hashedUserId) {
                        _userIdHash = hashedUserId;
                      };

                      g.analyticsEnabled = true;
                    } else {
                      console.error("EASYBASE â€” React Native analytics requires the presence of 'googleAnalyticsSecret'. To create a new secret, navigate in the Google Analytics UI to: Admin > Data Streams > choose your stream > Measurement Protocol > Create");
                    }
                  }
                }();

                if (_temp13 && _temp13.then) return _temp13.then(function () {});
              } else if (options.googleAnalyticsId.startsWith("UA-")) {
                console.error("EASYBASE â€” Detected Universal Analytics tag in googleAnalyticsId parameter. This version is not supported â€“Â please update to Google Analytics 4.\nhttps://support.google.com/analytics/answer/9744165?hl=en");
              } else {
                console.error("EASYBASE â€” Unknown googleAnalyticsId version parameter. Please use Google Analytics 4.\nhttps://support.google.com/analytics/answer/9744165?hl=en");
              }
            }();

            if (_temp12 && _temp12.then) return _temp12.then(function () {});
          }
        }();

        return Promise.resolve(_temp11 && _temp11.then ? _temp11.then(_temp10) : _temp10(_temp11));
      } catch (e) {
        return Promise.reject(e);
      }
    };

    mount();
  }, []);

  var useFrameEffect = function useFrameEffect(effect) {
    _effect = effect;
  };

  React.useEffect(function () {
    if (userSignedIn === true && _ranSignInCallback.current === false && _signInCallback !== undefined) {
      _signInCallback();

      _ranSignInCallback.current = true;
    }
  }, [userSignedIn]);

  var onSignIn = function onSignIn(callback) {
    _signInCallback = callback;

    if (userSignedIn === true && _ranSignInCallback.current === false && _signInCallback !== undefined) {
      _signInCallback();

      _ranSignInCallback.current = true;
    }
  };

  React.useEffect(function () {
    _observableFrame.observe(function (allChanges) {
      allChanges.forEach(function (change) {
        _observedChangeStack.push({
          type: change.type,
          path: change.path,
          value: change.value,
          _id: _recordIdMap.get(_frame[Number(change.path[0])]) // Not bringing change.object or change.oldValue

        });

        log(JSON.stringify({
          type: change.type,
          path: change.path,
          value: change.value,
          _id: _recordIdMap.get(_frame[Number(change.path[0])]) // Not bringing change.object or change.oldValue

        }));
      });
    });

    _proxyRecordMap = new WeakMap();

    _frame.forEach(function (_, i) {
      return _proxyRecordMap.set(_observableFrame[i], "" + i);
    });

    _effect(); // call useFrameEffect

  }, [_observableFrame]);
  React.useEffect(function () {
    _observableFrame.unobserve();

    _setObservableFrame(E.from(_frame));
  }, [_frame]);

  function Frame(index) {
    if (typeof index === "number") {
      return _observableFrame[index];
    } else {
      return _observableFrame;
    }
  }

  var _recordIDExists = function _recordIDExists(record) {
    return !!_recordIdMap.get(record) || !!_recordIdMap.get(_getRawRecordFromProxy(record) || {});
  };

  var _getRawRecordFromProxy = function _getRawRecordFromProxy(proxyRecord) {
    return _proxyRecordMap.get(proxyRecord) ? _frame[+_proxyRecordMap.get(proxyRecord)] : undefined;
  };

  var configureFrame = function configureFrame(options) {
    _frameConfiguration = _extends({}, _frameConfiguration);
    if (options.limit !== undefined) _frameConfiguration.limit = options.limit;
    if (options.offset !== undefined && options.offset >= 0) _frameConfiguration.offset = options.offset;
    if (options.tableName !== undefined) _frameConfiguration.tableName = options.tableName;
    _isFrameInitialized = false;
    return {
      message: "Successfully configured frame. Run sync() for changes to be shown in frame",
      success: true
    };
  };

  var currentConfiguration = function currentConfiguration() {
    return _extends({}, _frameConfiguration);
  };

  var addRecord = function addRecord(options) {
    try {
      var defaultValues = {
        insertAtEnd: false,
        newRecord: {},
        tableName: undefined
      };

      var fullOptions = _extends({}, defaultValues, options);

      return Promise.resolve(_catch(function () {
        return Promise.resolve(tokenPost(POST_TYPES$1.SYNC_INSERT, fullOptions)).then(function (res) {
          return {
            message: res.data,
            success: res.success
          };
        });
      }, function (err) {
        console.error("Easybase Error: addRecord failed ", err);
        return {
          message: "Easybase Error: addRecord failed " + err,
          success: false,
          errorCode: err
        };
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  var deleteRecord = function deleteRecord(options) {
    try {
      var _frameRecord = _getRawRecordFromProxy(options.record) || _frame.find(function (ele) {
        return fastDeepEqual(ele, options.record);
      });

      if (_frameRecord && _recordIdMap.get(_frameRecord)) {
        return Promise.resolve(tokenPost(POST_TYPES$1.SYNC_DELETE, {
          _id: _recordIdMap.get(_frameRecord),
          tableName: options.tableName
        })).then(function (res) {
          return {
            success: res.success,
            message: res.data
          };
        });
      } else {
        return Promise.resolve(_catch(function () {
          return Promise.resolve(tokenPost(POST_TYPES$1.SYNC_DELETE, {
            record: options.record,
            tableName: options.tableName
          })).then(function (res) {
            return {
              success: res.success,
              message: res.data
            };
          });
        }, function (error) {
          console.error("Easybase Error: deleteRecord failed ", error);
          return {
            success: false,
            message: "Easybase Error: deleteRecord failed " + error,
            errorCode: error.errorCode || undefined
          };
        }));
      }
    } catch (e) {
      return Promise.reject(e);
    }
  }; // Only allow the deletion of one element at a time
  // First handle shifting of the array size. Then iterate


  var sync = function sync() {
    try {
      var _temp17 = function _temp17() {
        return _catch(function () {
          return Promise.resolve(tokenPost(POST_TYPES$1.GET_FRAME, _frameConfiguration)).then(function (res) {
            if (res.success === false) {
              console.error(res.data);
              setIsSyncing(false);
              return {
                success: false,
                message: "" + res.data
              };
            } else {
              _isFrameInitialized = true;

              _realignFrames(res.data);

              setIsSyncing(false);
              return {
                message: 'Success. Call frame for data',
                success: true
              };
            }
          }); // Check if the array received from db is the same as frame
          // If not, update it and send useFrameEffect
        }, function (error) {
          console.error("Easybase Error: get failed ", error);
          setIsSyncing(false);
          return {
            success: false,
            message: "Easybase Error: get failed " + error,
            errorCode: error.errorCode || undefined
          };
        });
      };

      var _realignFrames = function _realignFrames(newData) {
        var isNewDataTheSame = true;

        if (newData.length !== _frame.length) {
          isNewDataTheSame = false;
        } else {
          for (var i = 0; i < newData.length; i++) {
            var newDataNoId = _extends({}, newData[i]);

            delete newDataNoId._id;

            if (!fastDeepEqual(newDataNoId, _frame[i])) {
              isNewDataTheSame = false;
              break;
            }
          }
        }

        if (!isNewDataTheSame) {
          _recordIdMap = new WeakMap();
          _frame.length = newData.length;
          newData.forEach(function (currNewEle, i) {
            _frame[i] = currNewEle;

            _recordIdMap.set(currNewEle, currNewEle._id);

            delete currNewEle._id;
          });

          _setFrame([].concat(_frame));
        }
      };

      if (isSyncing) {
        return Promise.resolve({
          success: false,
          message: "Easybase Error: the provider is currently syncing, use 'await sync()' before calling sync() again"
        });
      }

      setIsSyncing(true);

      var _temp18 = function () {
        if (_isFrameInitialized) {
          var _temp19 = function () {
            if (_observedChangeStack.length > 0) {
              log("Stack change: ", _observedChangeStack);
              return Promise.resolve(tokenPost(POST_TYPES$1.SYNC_STACK, _extends({
                stack: _observedChangeStack
              }, _frameConfiguration))).then(function (res) {
                if (res.success) {
                  _observedChangeStack.length = 0;
                }
              });
            }
          }();

          if (_temp19 && _temp19.then) return _temp19.then(function () {});
        }
      }();

      return Promise.resolve(_temp18 && _temp18.then ? _temp18.then(_temp17) : _temp17(_temp18));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  var updateRecordImage = function updateRecordImage(options) {
    return Promise.resolve(_updateRecordAttachment(options, "image"));
  };

  var updateRecordVideo = function updateRecordVideo(options) {
    return Promise.resolve(_updateRecordAttachment(options, "video"));
  };

  var updateRecordFile = function updateRecordFile(options) {
    return Promise.resolve(_updateRecordAttachment(options, "file"));
  };

  var _updateRecordAttachment = function _updateRecordAttachment(options, type) {
    try {
      var isFileFromURI = function isFileFromURI(f) {
        return f.uri !== undefined;
      };

      var _frameRecord = _getRawRecordFromProxy(options.record) || _frame.find(function (ele) {
        return fastDeepEqual(ele, options.record);
      });

      if (_frameRecord === undefined || !_recordIDExists(_frameRecord)) {
        log("Attempting to add attachment to a new record that has not been synced. Please sync() before trying to add attachment.");
        return Promise.resolve({
          success: false,
          message: "Attempting to add attachment to a new record that has not been synced. Please sync() before trying to add attachment."
        });
      }

      var ext = options.attachment.name.split(".").pop().toLowerCase();
      log(ext);

      if (type === "image" && !imageExtensions$1.includes(ext)) {
        return Promise.resolve({
          success: false,
          message: "Image files must have a proper image extension in the file name"
        });
      }

      if (type === "video" && !videoExtensions$1.includes(ext)) {
        return Promise.resolve({
          success: false,
          message: "Video files must have a proper video extension in the file name"
        });
      }

      var formData = new FormData();

      if (isFileFromURI(options.attachment)) {
        formData.append("file", options.attachment);
        formData.append("name", options.attachment.name);
      } else {
        formData.append("file", options.attachment);
        formData.append("name", options.attachment.name);
      }

      var customHeaders = {
        'Eb-upload-type': type,
        'Eb-column-name': options.columnName,
        'Eb-record-id': _recordIdMap.get(_frameRecord),
        'Eb-table-name': options.tableName
      };
      return Promise.resolve(tokenPostAttachment(formData, customHeaders)).then(function (res) {
        return Promise.resolve(sync()).then(function () {
          return {
            message: res.data,
            success: res.success
          };
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  var isUserSignedIn = function isUserSignedIn() {
    return userSignedIn;
  };

  g.newTokenCallback = function () {
    var cookieName = g.ebconfig.integration.slice(-10);

    if (!g.token) {
      // User signed out
      cache.clearCacheTokens(cookieName).then(function (_) {
        setUserSignedIn(false);
        _ranSignInCallback.current = false;
      });
    } else {
      // User signed in or refreshed token
      cache.setCacheTokens(g, cookieName).then(function (_) {
        setUserSignedIn(true);
      });
    }
  };

  var useReturn = function useReturn(dbInstance, deps) {
    // eslint-disable-next-line no-extra-parens
    var _useState6 = React.useState(function () {
      return function () {};
    }),
        unsubscribe = _useState6[0],
        setUnsubscribe = _useState6[1];

    var _useState7 = React.useState([]),
        frame = _useState7[0],
        setFrame = _useState7[1];

    var _useState8 = React.useState(null),
        error = _useState8[0],
        setError = _useState8[1];

    var _useState9 = React.useState(false),
        loading = _useState9[0],
        setLoading = _useState9[1];

    var _useState10 = React.useState(false),
        dead = _useState10[0],
        setDead = _useState10[1];

    var doFetch = function doFetch() {
      try {
        var _temp22 = function _temp22() {
          setLoading(false);
        };

        setLoading(true);

        var _temp23 = _catch(function () {
          return Promise.resolve(dbInstance().all()).then(function (res) {
            if (Array.isArray(res)) {
              setFrame(res);
            }
          });
        }, function (error) {
          setError(error);
        });

        return Promise.resolve(_temp23 && _temp23.then ? _temp23.then(_temp22) : _temp22(_temp23));
      } catch (e) {
        return Promise.reject(e);
      }
    };

    React.useEffect(function () {
      var isAlive = true;

      if (!dead) {
        var _instanceTableName = dbInstance()._tableName;

        unsubscribe("true");

        var _listener = dbEventListener(function (status, queryType, executeCount, tableName, returned) {
          if (!isAlive) {
            return;
          }

          log(_instanceTableName, status, queryType, executeCount, tableName);

          if (tableName === null && _instanceTableName === "untable" || tableName === _instanceTableName) {
            if (status === DB_STATUS$1.SUCCESS && queryType !== "select") {
              if (typeof returned === "number" && returned > 0) {
                doFetch();
              } else if (Array.isArray(returned) && typeof returned[0] === "number" && returned[0] > 0) {
                doFetch();
              }
            }
          }
        });

        setUnsubscribe(function () {
          return function (stayAlive) {
            _listener();

            stayAlive !== "true" && setDead(true);
          };
        });
        doFetch();
      }

      return function () {
        isAlive = false;
      };
    }, deps || []);
    return {
      frame: frame,
      unsubscribe: unsubscribe,
      error: error,
      manualFetch: doFetch,
      loading: loading
    };
  };

  var c = {
    configureFrame: configureFrame,
    addRecord: addRecord,
    deleteRecord: deleteRecord,
    sync: sync,
    updateRecordImage: updateRecordImage,
    updateRecordVideo: updateRecordVideo,
    updateRecordFile: updateRecordFile,
    Frame: Frame,
    useFrameEffect: useFrameEffect,
    fullTableSize: fullTableSize,
    tableTypes: tableTypes,
    currentConfiguration: currentConfiguration,
    Query: Query,
    signIn: signIn,
    signOut: signOut,
    isUserSignedIn: isUserSignedIn,
    signUp: signUp,
    setUserAttribute: setUserAttribute,
    getUserAttributes: getUserAttributes,
    resetUserPassword: resetUserPassword,
    onSignIn: onSignIn,
    db: db,
    dbEventListener: dbEventListener,
    e: e,
    setFile: setFile,
    setImage: setImage,
    setVideo: setVideo,
    useReturn: useReturn,
    forgotPassword: forgotPassword,
    forgotPasswordConfirm: forgotPasswordConfirm,
    userID: userID
  };
  return React__default["default"].createElement(EasybaseContext.Provider, {
    value: c
  }, mounted && children);
};

var useEasybase = function useEasybase() {
  var easybase = React.useContext(EasybaseContext);
  return easybase;
};

var Auth = React.lazy(function () {
  return Promise.resolve().then(function () { return require('./Auth-dec80812.js'); }).then(function (n) { return n.Auth; });
});
function index (props) {
  return React__default["default"].createElement(React.Suspense, {
    fallback: React__default["default"].createElement(React.Fragment, null)
  }, React__default["default"].createElement(Auth, Object.assign({}, props)));
}
/**
 * Note that this wrapper component exists to force code-splitting
 */

exports.EasybaseProvider = EasybaseProvider;
exports._extends = _extends;
exports.commonjsGlobal = commonjsGlobal;
exports.createCommonjsModule = createCommonjsModule;
exports.getDefaultExportFromCjs = getDefaultExportFromCjs;
exports.index = index;
exports.useEasybase = useEasybase;
//# sourceMappingURL=index-04d24c4d.js.map
