function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

/**
 * Ported from https://github.com/sunnylqm/react-native-storage
 * Credit: Sunny Luo /sunnylqm
 */

/**
 * Created by sunny on 9/1/16.
 */
var NotFoundError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(NotFoundError, _Error);

  function NotFoundError(message) {
    var _this;

    _this = _Error.call(this, "Not Found! Params: " + message) || this;
    _this.name = 'NotFoundError';
    _this.stack = new Error().stack; // Optional

    return _this;
  }

  return NotFoundError;
}( /*#__PURE__*/_wrapNativeSuper(Error)); // NotFoundError.prototype = Object.create(Error.prototype);

var ExpiredError = /*#__PURE__*/function (_Error2) {
  _inheritsLoose(ExpiredError, _Error2);

  function ExpiredError(message) {
    var _this2;

    _this2 = _Error2.call(this, "Expired! Params: " + message) || this;
    _this2.name = 'ExpiredError';
    _this2.stack = new Error().stack; // Optional

    return _this2;
  }

  return ExpiredError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

var Storage = /*#__PURE__*/function () {
  function Storage(options) {
    var _this = this;

    if (options === void 0) {
      options = {};
    }

    this._SIZE = options.size || 1000; // maximum key-ids capacity

    this.sync = options.sync || {}; // remote sync method

    this.defaultExpires = options.defaultExpires !== undefined ? options.defaultExpires : 1000 * 3600 * 24;
    this.enableCache = options.enableCache !== false;
    this._s = options.storageBackend || null;
    this._innerVersion = 11;
    this.cache = {};

    if (this._s && this._s.setItem) {
      try {
        var promiseTest = this._s.setItem('__react_native_storage_test', 'test');

        this.isPromise = !!(promiseTest && promiseTest.then);
      } catch (e) {
        console.warn(e);
        delete this._s;
        throw e;
      }
    } else {
      console.warn("Data would be lost after reload cause there is no storageBackend specified!\n      \nEither use localStorage(for web) or AsyncStorage(for React Native) as a storageBackend.");
    }

    this._mapPromise = this.getItem('map').then(function (map) {
      _this._m = _this._checkMap(map && JSON.parse(map) || {});
    });
  }

  var _proto = Storage.prototype;

  _proto.getItem = function getItem(key) {
    return this._s ? this.isPromise ? this._s.getItem(key) : Promise.resolve(this._s.getItem(key)) : Promise.resolve();
  };

  _proto.setItem = function setItem(key, value) {
    return this._s ? this.isPromise ? this._s.setItem(key, value) : Promise.resolve(this._s.setItem(key, value)) : Promise.resolve();
  };

  _proto.removeItem = function removeItem(key) {
    return this._s ? this.isPromise ? this._s.removeItem(key) : Promise.resolve(this._s.removeItem(key)) : Promise.resolve();
  };

  _proto._initMap = function _initMap() {
    return {
      innerVersion: this._innerVersion,
      index: 0,
      __keys__: {}
    };
  };

  _proto._checkMap = function _checkMap(map) {
    if (map && map.innerVersion && map.innerVersion === this._innerVersion) {
      return map;
    } else {
      return this._initMap();
    }
  };

  _proto._getId = function _getId(key, id) {
    return key + '_' + id;
  };

  _proto._saveToMap = function _saveToMap(params) {
    var key = params.key,
        id = params.id,
        data = params.data,
        newId = this._getId(key, id),
        m = this._m;

    if (m[newId] !== undefined) {
      // update existing data
      if (this.enableCache) this.cache[newId] = JSON.parse(data);
      return this.setItem('map_' + m[newId], data);
    }

    if (m[m.index] !== undefined) {
      // loop over, delete old data
      var oldId = m[m.index];
      var splitOldId = oldId.split('_');
      delete m[oldId];

      this._removeIdInKey(splitOldId[0], splitOldId[1]);

      if (this.enableCache) {
        delete this.cache[oldId];
      }
    }

    m[newId] = m.index;
    m[m.index] = newId;
    m.__keys__[key] = m.__keys__[key] || [];

    m.__keys__[key].push(id);

    if (this.enableCache) {
      var cacheData = JSON.parse(data);
      this.cache[newId] = cacheData;
    }

    var currentIndex = m.index;

    if (++m.index === this._SIZE) {
      m.index = 0;
    }

    this.setItem('map_' + currentIndex, data);
    this.setItem('map', JSON.stringify(m));
  };

  _proto.save = function save(params) {
    var _this2 = this;

    var key = params.key,
        id = params.id,
        data = params.data,
        rawData = params.rawData,
        _params$expires = params.expires,
        expires = _params$expires === void 0 ? this.defaultExpires : _params$expires;

    if (key.toString().indexOf('_') !== -1) {
      console.error('Please do not use "_" in key!');
    }

    var dataToSave = {
      rawData: data
    };

    if (data === undefined) {
      if (rawData !== undefined) {
        console.warn('"rawData" is deprecated, please use "data" instead!');
        dataToSave.rawData = rawData;
      } else {
        console.error('"data" is required in save()!');
        return;
      }
    }

    var now = Date.now();

    if (expires !== null) {
      dataToSave.expires = now + expires;
    }

    dataToSave = JSON.stringify(dataToSave);

    if (id === undefined) {
      if (this.enableCache) {
        var cacheData = JSON.parse(dataToSave);
        this.cache[key] = cacheData;
      }

      return this.setItem(key, dataToSave);
    } else {
      if (id.toString().indexOf('_') !== -1) {
        console.error('Please do not use "_" in id!');
      }

      return this._mapPromise.then(function () {
        return _this2._saveToMap({
          key: key,
          id: id,
          data: dataToSave
        });
      });
    }
  };

  _proto.getBatchData = function getBatchData(querys) {
    var _this3 = this;

    return Promise.all(querys.map(function (query) {
      return _this3.load(query);
    }));
  };

  _proto.getBatchDataWithIds = function getBatchDataWithIds(params) {
    try {
      var _this5 = this;

      var key = params.key,
          ids = params.ids,
          syncInBackground = params.syncInBackground,
          syncParams = params.syncParams;
      var tasks = ids.map(function (id) {
        return _this5.load({
          key: key,
          id: id,
          syncInBackground: syncInBackground,
          autoSync: false,
          batched: true
        });
      });
      return Promise.resolve(Promise.all(tasks)).then(function (results) {
        var missingIds = [];
        results.forEach(function (value) {
          if (value.syncId !== undefined) {
            missingIds.push(value.syncId);
          }
        });

        if (missingIds.length) {
          return Promise.resolve(_this5.sync[key]({
            id: missingIds,
            syncParams: syncParams
          })).then(function (syncData) {
            return results.map(function (value) {
              return value.syncId ? syncData.shift() : value;
            });
          });
        } else {
          return results;
        }
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto._lookupGlobalItem = function _lookupGlobalItem(params) {
    var _this6 = this;

    var key = params.key;

    if (this.enableCache && this.cache[key] !== undefined) {
      return this._loadGlobalItem(_extends({
        ret: this.cache[key]
      }, params));
    }

    return this.getItem(key).then(function (ret) {
      return _this6._loadGlobalItem(_extends({
        ret: ret
      }, params));
    });
  };

  _proto._loadGlobalItem = function _loadGlobalItem(params) {
    var key = params.key,
        ret = params.ret,
        autoSync = params.autoSync,
        syncInBackground = params.syncInBackground,
        syncParams = params.syncParams;

    if (ret === null || ret === undefined) {
      if (autoSync && this.sync[key]) {
        return this.sync[key]({
          syncParams: syncParams
        });
      }

      throw new NotFoundError(JSON.stringify(params));
    }

    if (typeof ret === 'string') {
      ret = JSON.parse(ret);

      if (this.enableCache) {
        this.cache[key] = ret;
      }
    }

    var now = Date.now();

    if (ret.expires < now) {
      if (autoSync && this.sync[key]) {
        if (syncInBackground) {
          try {
            this.sync[key]({
              syncParams: syncParams,
              syncInBackground: syncInBackground
            });
          } catch (e) {// avoid uncaught exception
          }

          return ret.rawData;
        }

        return this.sync[key]({
          syncParams: syncParams,
          syncInBackground: syncInBackground
        });
      }

      throw new ExpiredError(JSON.stringify(params));
    }

    return ret.rawData;
  };

  _proto._noItemFound = function _noItemFound(params) {
    var key = params.key,
        id = params.id,
        autoSync = params.autoSync,
        syncParams = params.syncParams;

    if (this.sync[key]) {
      if (autoSync) {
        return this.sync[key]({
          id: id,
          syncParams: syncParams
        });
      }

      return {
        syncId: id
      };
    }

    throw new NotFoundError(JSON.stringify(params));
  };

  _proto._loadMapItem = function _loadMapItem(params) {
    var ret = params.ret,
        key = params.key,
        id = params.id,
        autoSync = params.autoSync,
        batched = params.batched,
        syncInBackground = params.syncInBackground,
        syncParams = params.syncParams;

    if (ret === null || ret === undefined) {
      return this._noItemFound(params);
    }

    if (typeof ret === 'string') {
      ret = JSON.parse(ret);
      var _key = params.key,
          _id = params.id;

      var newId = this._getId(_key, _id);

      if (this.enableCache) {
        this.cache[newId] = ret;
      }
    }

    var now = Date.now();

    if (ret.expires < now) {
      if (autoSync && this.sync[key]) {
        if (syncInBackground) {
          try {
            this.sync[key]({
              id: id,
              syncParams: syncParams,
              syncInBackground: syncInBackground
            });
          } catch (e) {// avoid uncaught exception
          }

          return ret.rawData;
        }

        return this.sync[key]({
          id: id,
          syncParams: syncParams,
          syncInBackground: syncInBackground
        });
      }

      if (batched) {
        return {
          syncId: id
        };
      }

      throw new ExpiredError(JSON.stringify(params));
    }

    return ret.rawData;
  };

  _proto._lookUpInMap = function _lookUpInMap(params) {
    var _this7 = this;

    var ret;
    var m = this._m;
    var key = params.key,
        id = params.id;

    var newId = this._getId(key, id);

    if (this.enableCache && this.cache[newId]) {
      ret = this.cache[newId];
      return this._loadMapItem(_extends({
        ret: ret
      }, params));
    }

    if (m[newId] !== undefined) {
      return this.getItem('map_' + m[newId]).then(function (ret) {
        return _this7._loadMapItem(_extends({
          ret: ret
        }, params));
      });
    }

    return this._noItemFound(_extends({
      ret: ret
    }, params));
  };

  _proto.remove = function remove(params) {
    var _this8 = this;

    return this._mapPromise.then(function () {
      var m = _this8._m;
      var key = params.key,
          id = params.id;

      if (id === undefined) {
        if (_this8.enableCache && _this8.cache[key]) {
          delete _this8.cache[key];
        }

        return _this8.removeItem(key);
      }

      var newId = _this8._getId(key, id); // remove existing data


      if (m[newId] !== undefined) {
        if (_this8.enableCache && _this8.cache[newId]) {
          delete _this8.cache[newId];
        }

        _this8._removeIdInKey(key, id);

        var idTobeDeleted = m[newId];
        delete m[newId];

        _this8.setItem('map', JSON.stringify(m));

        return _this8.removeItem('map_' + idTobeDeleted);
      }
    });
  };

  _proto._removeIdInKey = function _removeIdInKey(key, id) {
    var indexTobeRemoved = (this._m.__keys__[key] || []).indexOf(id);

    if (indexTobeRemoved !== -1) {
      this._m.__keys__[key].splice(indexTobeRemoved, 1);
    }
  };

  _proto.load = function load(params) {
    var _this9 = this;

    var key = params.key,
        id = params.id,
        _params$autoSync = params.autoSync,
        autoSync = _params$autoSync === void 0 ? true : _params$autoSync,
        _params$syncInBackgro = params.syncInBackground,
        syncInBackground = _params$syncInBackgro === void 0 ? true : _params$syncInBackgro,
        syncParams = params.syncParams,
        batched = params.batched;
    return this._mapPromise.then(function () {
      if (id === undefined) {
        return _this9._lookupGlobalItem({
          key: key,
          autoSync: autoSync,
          syncInBackground: syncInBackground,
          syncParams: syncParams
        });
      } else {
        return _this9._lookUpInMap({
          key: key,
          id: id,
          autoSync: autoSync,
          syncInBackground: syncInBackground,
          batched: batched,
          syncParams: syncParams
        });
      }
    });
  };

  _proto.clearAll = function clearAll() {
    this._s.clear && this._s.clear();
    this._m = this._initMap();
  };

  _proto.clearMap = function clearMap() {
    var _this10 = this;

    return this.removeItem('map').then(function () {
      _this10.cache = {};
      _this10._m = _this10._initMap();
    });
  };

  _proto.clearMapForKey = function clearMapForKey(key) {
    var _this11 = this;

    return this._mapPromise.then(function () {
      var tasks = (_this11._m.__keys__[key] || []).map(function (id) {
        return _this11.remove({
          key: key,
          id: id
        });
      });
      return Promise.all(tasks);
    });
  };

  _proto.getIdsForKey = function getIdsForKey(key) {
    var _this12 = this;

    return this._mapPromise.then(function () {
      return _this12._m.__keys__[key] || [];
    });
  };

  _proto.getAllDataForKey = function getAllDataForKey(key, options) {
    var _this13 = this;

    options = Object.assign({
      syncInBackground: true
    }, options);
    return this.getIdsForKey(key).then(function (ids) {
      var querys = ids.map(function (id) {
        return {
          key: key,
          id: id,
          syncInBackground: options.syncInBackground
        };
      });
      return _this13.getBatchData(querys);
    });
  };

  return Storage;
}();

// https://github.com/sunnylqm/react-native-storage
function _catch(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }

  if (result && result.then) {
    return result.then(void 0, recover);
  }

  return result;
}

var setCacheTokens = function setCacheTokens(g, cookieName) {
  try {
    return Promise.resolve(storage.save({
      key: cookieName + "token",
      data: g.token,
      expires: 3600 * 1000 * 24
    })).then(function () {
      return Promise.resolve(storage.save({
        key: cookieName + "refreshToken",
        data: g.refreshToken,
        expires: 3600 * 1000 * 24
      })).then(function () {
        return Promise.resolve(storage.save({
          key: cookieName + "session",
          data: g.session,
          expires: null
        })).then(function () {});
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};
var clearCacheTokens = function clearCacheTokens(cookieName) {
  try {
    return Promise.resolve(storage.remove({
      key: cookieName + "token"
    })).then(function () {
      return Promise.resolve(storage.remove({
        key: cookieName + "refreshToken"
      })).then(function () {
        return Promise.resolve(storage.remove({
          key: cookieName + "session"
        })).then(function () {});
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};
var getCacheTokens = function getCacheTokens(cookieName) {
  try {
    var _temp7 = function _temp7() {
      function _temp4() {
        function _temp2() {
          return {
            cacheToken: cacheToken,
            cacheRefreshToken: cacheRefreshToken,
            cacheSession: cacheSession
          };
        }

        var _temp = _catch(function () {
          return Promise.resolve(storage.load({
            key: cookieName + "session"
          })).then(function (_storage$load3) {
            cacheSession = _storage$load3;
          });
        }, function () {});

        return _temp && _temp.then ? _temp.then(_temp2) : _temp2(_temp);
      }

      var _temp3 = _catch(function () {
        return Promise.resolve(storage.load({
          key: cookieName + "refreshToken"
        })).then(function (_storage$load2) {
          cacheRefreshToken = _storage$load2;
        });
      }, function () {});

      return _temp3 && _temp3.then ? _temp3.then(_temp4) : _temp4(_temp3);
    };

    var cacheToken = false;
    var cacheRefreshToken = false;
    var cacheSession = false;

    var _temp8 = _catch(function () {
      return Promise.resolve(storage.load({
        key: cookieName + "token"
      })).then(function (_storage$load) {
        cacheToken = _storage$load;
      });
    }, function () {});

    return Promise.resolve(_temp8 && _temp8.then ? _temp8.then(_temp7) : _temp7(_temp8));
  } catch (e) {
    return Promise.reject(e);
  }
};

var RN = require('react-native');

var storage = new Storage({
  storageBackend: RN.AsyncStorage
});

exports.clearCacheTokens = clearCacheTokens;
exports.getCacheTokens = getCacheTokens;
exports.setCacheTokens = setCacheTokens;
//# sourceMappingURL=cache.native.js.map
