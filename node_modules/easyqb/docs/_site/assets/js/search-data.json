{"0": {
    "doc": "Delete",
    "title": "Overview",
    "content": ". | With .with .withRecursive | Delete .delete | From .from | Using .from | Where .where | Returning .return | . ",
    "url": "http://localhost:4000/docs/delete_queries.html#overview",
    "relUrl": "/docs/delete_queries.html#overview"
  },"1": {
    "doc": "Delete",
    "title": "Delete",
    "content": "Delete queries look like Select queries with an additional call to .delete. sq.delete.from`person`.query sq.from`person`.delete.query // equivalent { text: 'delete from person', args: [] } .delete is idempotent. sq`book`.delete.delete.delete.query { text: 'delete from book', args: [] } . ",
    "url": "http://localhost:4000/docs/delete_queries.html",
    "relUrl": "/docs/delete_queries.html"
  },"2": {
    "doc": "Delete",
    "title": "From",
    "content": ".from works it does in Select queries. However, be aware of certain SQL constraints Sqorn does not yet enforce. | Delete queries require exactly one, named table. | The table may not be a subquery or expression. | Joins are not allowed. | . Reference more than one table by using: . | Subqueries in the Where clause | With clause (CTE) join tables | Dialect-specific SQL extensions | . ",
    "url": "http://localhost:4000/docs/delete_queries.html#from",
    "relUrl": "/docs/delete_queries.html#from"
  },"3": {
    "doc": "Delete",
    "title": "Using",
    "content": "Postgres Only: The first .from call forms the delete clause. Subsequent .from calls form the using clause. sq.delete .from`book` .from`author` .where`book.author_id = author.id and author.contract = 'terminated'` .query { text: \"delete from book using author where (book.author_id = author.id and author.contract = 'terminated')\", args: [] } . ",
    "url": "http://localhost:4000/docs/delete_queries.html#using",
    "relUrl": "/docs/delete_queries.html#using"
  },"4": {
    "doc": "Delete",
    "title": "Where",
    "content": "Filter the rows to delete with .where. sq.delete.from`person`.where`id = ${723}`.query { text: 'delete from person where (id = $1)', args: [723] } .where works it does in Select queries. ",
    "url": "http://localhost:4000/docs/delete_queries.html#where",
    "relUrl": "/docs/delete_queries.html#where"
  },"5": {
    "doc": "Delete",
    "title": "Returning",
    "content": "Postgres Only: Return the deleted rows with .return. sq.delete.from`person`.return`name`.query { text: 'delete from person returning name', args: [] } . ",
    "url": "http://localhost:4000/docs/delete_queries.html#returning",
    "relUrl": "/docs/delete_queries.html#returning"
  },"6": {
    "doc": "Delete",
    "title": "Express",
    "content": "Express syntax works. sq`person`({ job: 'student' })`name`.delete.query { text: 'delete from person where job = $1 returning name', args: ['student'] } . ",
    "url": "http://localhost:4000/docs/delete_queries.html#express",
    "relUrl": "/docs/delete_queries.html#express"
  },"7": {
    "doc": "Executing Queries",
    "title": "All Rows",
    "content": ".all executes a query and returns a Promise for an array of rows. A row is an object in the form { field: value }. By default, field names are converted to camelCase. The query builder is itself thenable so .all is optional. const People = sq.sql`select * from person` // four ways ways to print all people: console.log(await People.all()) console.log(await People) People.all().then(people =&gt; console.log(people)) People.then(people =&gt; console.log(people)) . ",
    "url": "http://localhost:4000/docs/executing_queries.html#all-rows",
    "relUrl": "/docs/executing_queries.html#all-rows"
  },"8": {
    "doc": "Executing Queries",
    "title": "One Row",
    "content": ".one fetches only the first result, or undefined if there are no matching results. The following all print the first person (or undefined). const Person = sq.sql`select * from person limit 1` // four ways ways to print the first person: Person.one().then(person =&gt; console.log(person)) Person.all().then(people =&gt; console.log(people[0]) console.log(await Person.one()) console.log((await Person)[0]) . ",
    "url": "http://localhost:4000/docs/executing_queries.html#one-row",
    "relUrl": "/docs/executing_queries.html#one-row"
  },"9": {
    "doc": "Executing Queries",
    "title": "Manually",
    "content": "You can use .query to build a query, then send its text and arguments to another library for execution. const pg = require('pg') const sqorn = require('@sqorn/pg') const pool = new pg.Pool() const sq = sqorn() const { text, args } = sq.from('book').query pool.query(text, args).then((err, res) =&gt; { console.log(res) }) .query is a getter method that compiles the query when accessed. Don’t call it twice. Never use .unparameterized to build a query string. It is vulnerable to SQL injection. ",
    "url": "http://localhost:4000/docs/executing_queries.html#manually",
    "relUrl": "/docs/executing_queries.html#manually"
  },"10": {
    "doc": "Executing Queries",
    "title": "Executing Queries",
    "content": ". | Execute .all .one | . ",
    "url": "http://localhost:4000/docs/executing_queries.html",
    "relUrl": "/docs/executing_queries.html"
  },"11": {
    "doc": "Expressions",
    "title": "Introduction",
    "content": "Access the expression API at sq.e. Create expressions by applying Operations like .add, .and, and .eq to values. SQL differentiates between operators and functions. Sqorn does not. const { e } = sq e.add(3, 4).query { text: '($1 + $2)', args: [3, 4] } . Create an expression from a value with .arg. e.arg('meow').query { text: '$1', args: ['meow'] } . e is short hand for e.arg. e('meow').query { text: '$1', args: ['meow'] } . Expressions are values. e(e(23)).query { text: '$1', args: [23] } . Expressions are immutable and composable. e.and( e.or(e.lt(3, 4), e.gt(5, 6)), e.neq(7, 8) ).query { text: '((($1 &lt; $2) or ($3 &gt; $4)) and ($5 &lt;&gt; $6))', args: [3, 4, 5, 6, 7, 8] } . All Operations have curried overloads. e.add(3)(4).query { text: '($1 + $2)', args: [3, 4] } . Supply raw arguments with tagged template literals. e.eq`lucky_number`(8).query { text: '(lucky_number = $1)', args: [8] } . A chained operation’s first argument is the expression it is called on. There is no operator precedence. Expressions are evaluated left to right. e(3).add(4).eq(7).and(true).query { text: '((($1 + $2) = $3) and $4)', args: [3, 4, 7, true] } . Pass multiple arguments to .arg to build a row value. e.arg(8, true)`meow`.query { text: '($1, $2, meow)', args: [8, true] } . Build expressions from Fragments and Subqueries. e(sq.txt`2`, sq.return`3`).query { text: '(2, (select 3))', args: [] } . undefined arguments are invalid. e.arg(undefined).query // throws error . Use null instead. e.arg(null).query { text: '$1', args: [null] } .unparameterized generates an unparameterized string. To avoid SQL injection, do not use this method. e.eq`genre`('fantasy').unparameterized \"(genre = 'fantasy')\" . Build queries from expressions. sq.return(e.add`n`(7)) .from({ n: e.unnest([2, 3, 4, 5]) }) .where(e`n`.mod(2).eq(0)) .query { text: 'select (n + $1) from unnest($2) n where ((n % $3) = $4)', args: [7, [2, 3, 4, 5], 2, 0] } . ",
    "url": "http://localhost:4000/docs/expressions.html#introduction",
    "relUrl": "/docs/expressions.html#introduction"
  },"12": {
    "doc": "Expressions",
    "title": "Type Safety",
    "content": "SQL is strongly typed. Sqorn expressions are somewhat typed. Calling an operation with incompatible arguments is a Typescript compilation error. For example, .add expects two number arguments, so supplying string or boolean arguments is invalid. Similarly, passing three arguments when two are expected is invalid. There are limits to expression type safety: . | The type of a null value cannot be inferred. Creating an expression from a null value will generate an Unknown Expression. | The type of a tagged template literal cannot be inferred. Creating an expression from a tagged template literal will generate an Unknown Expression. | Multidimensional types like Array Expression, Row Expression and Table Expression lose all information about their constituent types. Sqorn will not warn you if you build the invalid expression e.eq(e(true, false), e(3, 4)). | Some n-ary operations like .and take one or more arguments. Sqorn cannot enforce the argument minimum at compile time. Expression e.and() compiles but throws an error at runtime. | . ",
    "url": "http://localhost:4000/docs/expressions.html#type-safety",
    "relUrl": "/docs/expressions.html#type-safety"
  },"13": {
    "doc": "Expressions",
    "title": "Expression Types",
    "content": "Sqorn’s expression types are listed below: . Unknown . Unknown Expressions represent values of unknown type. They could be anything from true, null, and 'meow', to (true, 24), Array[3, 5, 7], and '{ \"hello\": \"world\" }'. Constructor: e.unknown . Compatible Types: any . Supported Operations: Comparison, Boolean, Math, String, Array, Row, Table . // Examples e(null) e`moo` e(sq.txt`moo`) e(e(null)) e.unknown('moo') . Boolean . Boolean Expressions represent values true and false. They are useful for constructing where, having and join conditions. Constructor: e.boolean . Compatible Types: boolean, null, BooleanExpression, UnknownExpression . Supported Operations: Comparison, Boolean . // Examples e(true) e(e(false)) e.boolean(null) e.and(true, false) e.eq(3, 6) e.like('moo', 'moomoo') e.eqAny(3, [2, 3, 5]) . Number . Number Expressions represent numbers like 2, 70.5, and -2749.234. Constructor: e.number . Compatible Types: number, null, NumberExpression, UnknownExpression . Supported Operations: Comparison, Math . // Examples e(8) e(e(8)) e.number(null) e.add(3, 4) e.sub(9)(6) e.div`moo``moo` e`moo`.mul`moo` . String . String Expressions represent character sequences like 'kitty', 'Tuxedo cats are best', and ''. Constructor: e.string . Compatible Types: string, null, StringExpression and UnknownExpression . Supported Operations: Comparison, String . // Examples e('moo') e.string(null) e(e('moo')) e.cat('moo', 'moo') . Array . Array Expressions represent Postgres Arrays. Constructor: e.array . Compatible Types: any[], null, Array Expression, Unknown Expression . Supported Operations: Comparison, Array . // Examples e([3, 4, 5]) e.array(null) e([true false]) e(e([])) e(['moo', 'moo', 'moo']) e(['moo']).cat(['moo']) . JSON . JSON Expressions represent JSON values. Constructor: e.json . | Compatible Types: null | number | boolean | string | [] | {}, JSONExpression, UnknownExpression | . Supported Operations: Comparison, JSON . // Examples e({ a: 1 }) e(e({})) e.json('moo') e.json(['moo', 'moo']) . Row . Row Expressions represent one or more values of any type. Constructor: e.row . Compatible Types: null, Row Expression, Unknown Expression . Supported Operations: Comparison, Row . // Examples e(1, true, 'moo') e(1)(true)('moo') e(e(1, 2)) e.row('moo') e.row`moo`('moo') . Table . Table Expressions represent a table. Constructor: e.table . Compatible Types: SQ, Table Expression, Unknown Expression . Supported Operations: Comparison, Table . // Examples e(sq.from('book')) e.unnest([3, 5, 7, 9]) e(sq.sql`select 'moo moo'`) e(e(sq.return`1`)) . ",
    "url": "http://localhost:4000/docs/expressions.html#expression-types",
    "relUrl": "/docs/expressions.html#expression-types"
  },"14": {
    "doc": "Expressions",
    "title": "Expressions",
    "content": " ",
    "url": "http://localhost:4000/docs/expressions.html",
    "relUrl": "/docs/expressions.html"
  },"15": {
    "doc": "Easybase Query Builder for JavaScript",
    "title": "Easybase Query Builder for JavaScript",
    "content": ". This project is based on sqorn using functional expressions and conditionals. It’s [almost] a subset, so some features included in Sqorn are not available in this package. More information on this is available below. If you’re just starting out, head to the Select page to begin. EasyQB is built into both easybase-react and easybasejs through the db function. It will become the standard query functionality for Easybase, replacing Frame which will become deprecated. The documentation outlined here is very much shortened version of that available on the Sqorn website. import Easybase from \"easybasejs\"; import ebconfig from \"./ebconfig.js\"; const table = Easybase.EasybaseProvider({ ebconfig }).db(); const { e } = table; const deletedNum = await table.delete.where(e.eq('app name', 'right now')).one(); // const t = await table.insert({ \"app name\": 'right now', _position: 0 }).one(); console.log(deletedNum) const res = await table.where(e.gt('rating', 15)).limit(10).all(); console.log(res); . Before using this library, you must create and account an account at easybase.io and configure your project. If you need more information, feel free to cautiously look at the Sqorn docs. This package is [almost] a subset of Sqorn, so not all features from that package will work with Easybase. This documentation should cover everything necessary to using this package with Easybase. Not included from Sqorn: . | Tagged template literals and the corresponding chaining | Manual building with .sql and .txt | Fragments | Distinct, Sets, and Join | SQL String Operations (.eq and others work) | Asynchronous transactions | The mapping Configurations | . Built With . | Sqorn | easybase.io | microbundle | . ",
    "url": "http://localhost:4000/",
    "relUrl": "/"
  },"16": {
    "doc": "Insert",
    "title": "Overview",
    "content": ". | With .with .withRecursive | Insert .from .insert | Returning .return | . ",
    "url": "http://localhost:4000/docs/insert_queries.html#overview",
    "relUrl": "/docs/insert_queries.html#overview"
  },"17": {
    "doc": "Insert",
    "title": "Insert",
    "content": ".from specifies the table to insert into and .insert specifies the data to insert.from works it does in delete queries. sq.from`person(first_name, last_name)` .insert`values (${'Shallan'}, ${'Davar'})` .query { text: 'insert into person(first_name, last_name) values ($1, $2)', args: ['Shallan', 'Davar'] } . To insert one row, pass .insert a single object. Column names are inferred from the object’s keys. Sqorn converts input object keys to snake_case by default. sq.from('person') .insert({ firstName: 'Shallan', lastName: 'Davar' }) .query { text: 'insert into person(first_name, last_name) values ($1, $2)', args: ['Shallan', 'Davar'] } . undefined values are inserted as default. default is a keyword, not a paraemeter. sq.from('test').insert({ a: undefined, b: null }).query { text: 'insert into test(a, b) values (default, $1)', args: [null] } . To insert multiple rows, pass multiple objects. Column names are inferred from the keys of all objects. sq.from('person') .insert( { firstName: 'Shallan', lastName: 'Davar' }, { firstName: 'Navani', lastName: 'Kholin' } ) .query { text: 'insert into person(first_name, last_name) values ($1, $2), ($3, $4)', args: ['Shallan', 'Davar', 'Navani', 'Kholin'] } . Alternatively, pass .insert an array of objects. sq.from('person') .insert([ { firstName: 'Shallan', lastName: 'Davar' }, { firstName: 'Navani', lastName: 'Kholin' } ]) .query { text: 'insert into person(first_name, last_name) values ($1, $2), ($3, $4)', args: ['Shallan', 'Davar', 'Navani', 'Kholin'] } . Values can be Expressions. sq.from('person').insert({ firstName: e.upper('moo') }).query { text: 'insert into person(first_name) values (upper($1))', args: ['moo'] } . Values can be Fragments. sq.from('person').insert({ firstName: sq.txt`'moo'` }).query { text: \"insert into person(first_name) values ('moo')\", args: [] } . Values can be Subqueries. sq.from('person').insert({ firstName: sq.return`${'Shallan'}`, lastName: sq.txt('Davar') }) .query { text: \"insert into person(first_name, last_name) values ((select $1), $2)\", args: ['Shallan', 'Davar'] } .insert accepts subqueries. sq.from('superhero(name)') .insert( sq.return`${'batman'}`.union(sq.return`${'superman'}`) ) .query { text: \"insert into superhero(name) (select $1 union (select $2))\", args: ['batman', 'superman'] } . Pass undefined to insert default values. sq.from('person').insert(undefined).query { text: 'insert into person default values', args: [] } . Only the last call to .insert is used. sq.from('person') .insert({ firstName: 'Shallan', lastName: 'Davar' }) .insert({ firstName: 'Navani', lastName: 'Kholin' }) .query { text: 'insert into person(first_name, last_name) values ($1, $2)', args: ['Navani', 'Kholin'] } . ",
    "url": "http://localhost:4000/docs/insert_queries.html",
    "relUrl": "/docs/insert_queries.html"
  },"18": {
    "doc": "Insert",
    "title": "Returning",
    "content": "Postgres Only: Return the inserted rows with .return. sq.from('book') .insert({ title: 'Squirrels and Acorns' }) .return('id') .query { text: 'insert into book(title) values ($1) returning id', args: ['Squirrels and Acorns'] } . ",
    "url": "http://localhost:4000/docs/insert_queries.html#returning",
    "relUrl": "/docs/insert_queries.html#returning"
  },"19": {
    "doc": "Insert",
    "title": "Express",
    "content": "Express syntax works. sq('book')()('id').insert({ title: 'Squirrels and Acorns' }).query { text: 'insert into book(title) values ($1) returning id', args: ['Squirrels and Acorns'] } . ",
    "url": "http://localhost:4000/docs/insert_queries.html#express",
    "relUrl": "/docs/insert_queries.html#express"
  },"20": {
    "doc": "Operations",
    "title": "Overview",
    "content": ". | Value arg unknown boolean number string array json row table | Boolean and or not isTrue isNotTrue isFalse isNotFalse isUnknown isNotUnknown | Comparison eq neq lt gt lte gte between notBetween isDistinctFrom isNotDistinctFrom isNull isNotNull in notIn | Quantified Comparison eqAny eqAll neqAny neqAll ltAny ltAll gtAny gtAll lteAny lteAll gteAny gteAll | Math add sub mul div mod exp sqrt cbrt fact | String cat like notLike likeAny likeAll notLikeAny notLikeAll similarTo notSimilarTo lower upper | Date and Time age now extract | Range | Aggregate count sum avg min max stddev variance | Conditional case coalesce nullif greatest least | Array cat arrayCat arrayGet arrayAppend unnest | JSON | Binary and or xor not shiftLeft shiftRight | Table union except except-all unionAll intersect intersectAll | . ",
    "url": "http://localhost:4000/docs/operations.html#overview",
    "relUrl": "/docs/operations.html#overview"
  },"21": {
    "doc": "Operations",
    "title": "Value",
    "content": "Arg . | arg: T =&gt; T | arg: T1 =&gt; T2 =&gt; ... Tn =&gt; row | .arg builds an expression from its argument. e.arg(23).query { text: '$1', args: [23] } . The argument determines the return type. e.arg(23) // NumberExpression e.arg(true) // BooleanExpression e.arg(null) // UnknownExpression e.arg('adsf') // StringExpression e.arg`hello` // UnknownExpression e.arg([1, 2]) // ArrayExpression e.arg({ hello: 'world' }) // JSONExpression e.arg(e.arg(23)) // NumberExpression . Multiple arguments build a Row Expression. e.arg(23, true) // RowExpression e.arg('moo', 'moo', 'meow') // RowExpression e.arg('moo')('moo') // RowExpression e.arg`moo``moo`('meow') // RowExpression . e is shorthand for e.arg. e(23) // NumberExpression e(true) // BooleanExpression . Like other operations .arg takes the expression it is called on its first argument. e(12).arg(23).arg(45) // equivalent to below e.arg(e.arg(e(12))(23))(45) // equivalent to above . Unknown . | unknown: any =&gt; unknown | .unknown builds an Unknown Expression. e.unknown(true) // UnknownExpression e.unknown(23) // UnknownExpression e.unknown(null) // UnknownExpression e.unknown(e('moo')) // UnknownExpression e.unknown`moo` // UnknownExpression . Avoid using .unknown. It is an escape hatch from Sqorn’s Type System. Any operation is possible on an Unknown Expression. e.unknown(true).add(23) . Boolean . | boolean: boolean =&gt; boolean | .boolean builds a Boolean Expression. e.boolean(true) // BooleanExpression e.boolean(false) // BooleanExpression e.boolean(null) // BooleanExpression e.boolean(e(true)) // BooleanExpression e.boolean`moo` // BooleanExpression . Number . | number: number =&gt; number | .number builds a Number Expression. e.number(23) // NumberExpression e.number(-999.23) // NumberExpression e.number(null) // NumberExpression e.number(e(0)) // NumberExpression e.number`moo` // NumberExpression . String . | string: string =&gt; string | .string builds a String Expression. e.string('adsf') // StringExpression e.string('moo moo') // StringExpression e.string(null) // StringExpression e.string(e('moo')) // StringExpression e.string`moo` // StringExpression . Array . | array: array =&gt; array | .string builds an Array Expression. e.array([]) // ArrayExpression e.array([2, 3, 5]) // ArrayExpression e.array(['moo', 'moo']) // ArrayExpression e.array(null) // ArrayExpression e.array(e([])) // ArrayExpression e.array`array['moo', 'moo']` // ArrayExpression . JSON . | json: json =&gt; json | .json builds a JSON Expression. e.json({ a: 'hi' }) // JSONExpression e.json([23]) // JSONExpression e.json(true) // JSONExpression e.json(23) // JSONExpression e.json('moo') // JSONExpression e.json(null) // JSONExpression e.json(e({})) // JSONExpression e.json`moo` // JSONExpression . Row . | row: row =&gt; row | row: T1 =&gt; T2 =&gt; ...Tn =&gt; row | .row builds a Row Expression. e.row(true, 23) // RowExpression e.row('moo', 'moo') // RowExpression e.row(true) // RowExpression e.row(23) // RowExpression e.row('moo') // RowExpression e.row(null) // RowExpression e.row(e.row(1, 2)) // RowExpression e.row(1, true, 'moo') // RowExpression e.row(1)(true)('moo') // RowExpression e.row`moo` // RowExpression . Table . | table: table =&gt; table | .table builds a Table Expression. e.table(null) // TableExpression e.table(sq.from('book')) // TableExpression e.table`moo` // TableExpression e.table(e.table`moo`) // TableExpression e.table(e.unnest([1, 2, 3])) // TableExpression . ",
    "url": "http://localhost:4000/docs/operations.html#value",
    "relUrl": "/docs/operations.html#value"
  },"22": {
    "doc": "Operations",
    "title": "Boolean",
    "content": "And . | and: boolean =&gt; ...boolean =&gt; boolean | .and performs logical conjunction on its arguments. e.and(true, false).query { text: '$1 and $2', args: [true, false] } . At least one argument is required. e.and().query // throws error e.and(true).query { text: '$1', args: [true] } . More than two arguments is allowed. e.and(true, false, true, false).query { text: '$1 and $2 and $3 and $4', args: [true, false, true, false] } . Chain and curry .and. e(true).and(false)(true).and`moo`.query { text: '$1 and $2 and $3 and moo', args: [true, false, true, true] } . Or . | or: boolean =&gt; ...boolean =&gt; boolean | .or performs logical disjunction on its arguments. e.or(true, false).query { text: '$1 or $2', args: [true, false] } . At least one argument is required. e.or().query // throws error e.or(true).query { text: '$1', args: [true] } . More than two arguments is allowed. e.or(true, false, true, false).query { text: '$1 or $2 or $3 or $4', args: [true, false, true, false] } . Chain and curry .or. e(true).or(false)(true).or`moo`.query { text: '$1 or $2 or $3 or moo', args: [true, false, true, true] } . Not . | not: boolean =&gt; boolean | .not performs logical negation on its argument. e.not(true).query { text: 'not($1)', args: [true] } . Chaining .not negates the Expression it is called on . e`moo`.not.query { text: 'not(moo)', args: [] } . Is True . | isTrue: boolean =&gt; boolean | .isTrue returns whether its argument is true. | Expression | Result | . | true is true | true | . | false is true | false | . | null is true | false | . e.isTrue(true).query { text: '$1 is true', args: [true] } . Chain .isTrue. e`moo`.isTrue.query { text: 'moo is true', args: [] } . Is Not True . | isNotTrue: boolean =&gt; boolean | .isNotTrue returns whether its argument is not true. | Expression | Result | . | true is not true | false | . | false is not true | true | . | null is not true | true | . e.isNotTrue(true).query { text: '$1 is not true', args: [true] } . Chain .isNotTrue. e`moo`.isNotTrue.query { text: 'moo is not true', args: [] } . Is False . | isFalse: boolean =&gt; boolean | .isFalse returns whether its argument is false. | Expression | Result | . | true is false | false | . | false is false | true | . | null is false | false | . e.isFalse(true).query { text: '$1 is false', args: [true] } . Chain .isFalse. e`moo`.isFalse.query { text: 'moo is false', args: [] } . Is Not False . | isNotFalse: boolean =&gt; boolean | .isNotFalse returns whether its argument is not false. | Expression | Result | . | true is not false | true | . | false is not false | false | . | null is not false | true | . e.isNotFalse(true).query { text: '$1 is not false', args: [true] } . Chain .isNotFalse. e`moo`.isNotFalse.query { text: 'moo is not false', args: [] } . Is Unknown . | isUnknown: boolean =&gt; boolean | .isUnknown returns whether its argument is null.isUnknown is equivalent to .isNull, except its arguments must be boolean. | Expression | Result | . | true is unknown | false | . | false is unknown | false | . | null is unknown | true | . e.isUnknown(true).query { text: '$1 is unknown', args: [true] } . Chain .isUnknown. e`moo`.isUnknown.query { text: 'moo is unknown', args: [] } . Is Not Unknown . | isNotUnknown: boolean =&gt; boolean | .isNotUnknown returns whether its argument is not null.isNotUnknown is equivalent to .isNotNull, except its argument must be boolean. | Expression | Result | . | true is not unknown | true | . | false is not unknown | true | . | null is not unknown | false | . e.isNotUnknown(true).query { text: '$1 is not unknown', args: [true] } . Chain .isNotUnknown. e`moo`.isNotUnknown.query { text: 'moo is not unknown', args: [] } . ",
    "url": "http://localhost:4000/docs/operations.html#boolean-1",
    "relUrl": "/docs/operations.html#boolean-1"
  },"23": {
    "doc": "Operations",
    "title": "Comparison",
    "content": "Equal . | eq: T =&gt; T =&gt; boolean | .eq returns whether its arguments are equal. e.eq('moo', 'moo').query { text: '$1 = $2', args: ['moo', 'moo'] } . Chain and curry .eq. e`moo`.eq`moo`.query { text: 'moo = moo', args: [] } . Not Equal . | neq: T =&gt; T =&gt; boolean | .neq returns whether its arguments are not equal. e.neq('moo', 'moo').query { text: '$1 &lt;&gt; $2', args: ['moo', 'moo'] } . Chain and curry .neq. e`moo`.neq`moo`.query { text: 'moo &lt;&gt; moo', args: [] } . Less Than . | lt: T =&gt; T =&gt; boolean | .lt returns whether its first argument is less than its second argument. e.lt('moo', 'moo').query { text: '$1 &lt; $2', args: ['moo', 'moo'] } . Chain and curry .lt. e`moo`.lt`moo`.query { text: 'moo &lt; moo', args: [] } . Greater Than . | gt: T =&gt; T =&gt; boolean | .gt returns whether its first argument is greater than its second argument. e.gt('moo', 'moo').query { text: '$1 &gt; $2', args: ['moo', 'moo'] } . Chain and curry .gt. e`moo`.gt`moo`.query { text: 'moo &gt; moo', args: [] } . Less Than or Equal . | lte: T =&gt; T =&gt; boolean | .lte returns whether its first argument is less than or equal to its second argument. e.lte('moo', 'moo').query { text: '$1 &lt;= $2', args: ['moo', 'moo'] } . Chain and curry .lte. e`moo`.lte`moo`.query { text: 'moo &lt;= moo', args: [] } . Greater Than or Equal . | gte: T =&gt; T =&gt; boolean | .gte returns whether its first argument is greater than or equal to its second argument. e.gte('moo', 'moo').query { text: '$1 &gt;= $2', args: ['moo', 'moo'] } . Chain and curry .gte. e`moo`.gte`moo`.query { text: 'moo &gt;= moo', args: [] } . Between . | between: T =&gt; T =&gt; T =&gt; boolean | .between returns whether its first argument is between its second and third arguments. e.between(5, 3, 9).query { text: '$1 between $2 and $3', args: [5, 3, 9] } . Chain and curry .between. e`moos`.between(3)(7).query { text: 'moomoo between $1 and $2', args: [3, 7] } . Not Between . | notBetween: T =&gt; T =&gt; T =&gt; boolean | .notBetween returns whether its first argument is not between its second and third arguments. e.notBetween(5, 3, 9).query { text: '$1 not between $2 and $3', args: [5, 3, 9] } . Chain and curry .notBetween. e`moos`.between(3)(7).query { text: 'moomoo not between $1 and $2', args: [3, 7] } . Is Distinct From . | isDistinctFrom: T =&gt; T =&gt; boolean | .isDistinctFrom returns whether its arguments are distinct. It is equivalent to .neq except it treats null a value. | Expression | Result | . | null &lt;&gt; null | null | . | null is distinct from null | false | . e.isDistinctFrom(3, null).query { text: '$1 is distinct from $2', args: [3, null] } . Chain and curry .isDistinctFrom. e`moo`.isDistinctFrom('moo').query { text: 'moom is distinct from $1', args: ['moo'] } . Is Not Distinct From . | isNotDistinctFrom: T =&gt; T =&gt; boolean | .isNotDistinctFrom returns whether its arguments are not distinct. It is equivalent to .eq except it treats null a value. | Expression | Result | . | null = null | null | . | null is not distinct from null | true | . e.isNotDistinctFrom(3, null).query { text: '$1 is not distinct from $2', args: [3, null] } . Chain and curry .isNotDistinctFrom. e`moo`.isNotDistinctFrom('moo').query { text: 'moom is not distinct from $1', args: ['moo'] } . Is Null . | isNull: T =&gt; boolean | .isNull returns whether its argument is null. | Expression | Result | . | true is null | false | . | false is null | false | . | null is null | true | . e.isNull(null).query { text: '$1 is null', args: [null] } . Chain .isNull. e`moo`.isNull.query { text: 'moo is null', args: [] } . Is Not Null . | isNotNull: T =&gt; boolean | .isNull returns whether its argument is not null. | Expression | Result | . | true is not null | true | . | false is not null | true | . | null is not null | false | . e.isNotNull(null).query { text: '$1 is not null', args: [null] } . Chain .isNotNull. e`moo`.isNotNull.query { text: 'moo is not null', args: [] } . In . | in: T =&gt; T[] =&gt; boolean | in: T =&gt; table =&gt; boolean | . Form 1.in returns whether a value is in a Values List. e.in(7, [5, 6, 7]).query { text: '$1 in ($2, $3, $4)', args: [7, 5, 6, 7] } . Form 2.in returns whether a value is in a Table. e.in(7, sq.sql`select 5 union (select 6) union (select 7)`).query { text: '$1 in (select 5 union (select 6) union (select 7))', args: [7] } .in is equivalent to .eqAny when the second argument is a table, but their overloads are different.in independently parameterizes each entry of its Values List.eqAny generates a single parameter from it Postgres Array. e.in(4, [3, 4, 5]).query { text: '$1 in ($2, $3, $4)', args: [4, 3, 4, 5] } e.eqAny(4, [3, 4, 5]).query { text: '$1 = any($2)', args: [4, [3, 4, 5]] } . Not In . | notIn: =&gt; T =&gt; table =&gt; boolean | notIn: =&gt; T =&gt; T[] =&gt; boolean | . Form 1.notIn returns whether a value is not in a Values List. e.notIn(7, [5, 6, 7]).query { text: '$1 not in ($2, $3, $4)', args: [7, 5, 6, 7] } . Form 2.notIn returns whether a value is not in a Table. e.notIn(7, sq.sql`select 5 union (select 6) union (select 7)`).query { text: '$1 not in (select 5 union (select 6) union (select 7))', args: [7] } .notIn is equivalent to .neqAll when the second argument is a table, but their overloads are different.notIn independently parameterizes each entry of its Values List.neqAll generates a single parameter from it Postgres Array. e.notIn(4, [3, 4, 5]).query { text: '$1 not in ($2, $3, $4)', args: [4, 3, 4, 5] } e.neqAll(4, [3, 4, 5]).query { text: '$1 &lt;&gt; all($2)', args: [4, [3, 4, 5]] } . ",
    "url": "http://localhost:4000/docs/operations.html#comparison",
    "relUrl": "/docs/operations.html#comparison"
  },"24": {
    "doc": "Operations",
    "title": "Quantified Comparison",
    "content": "Equal Any . | eqAny: T =&gt; array =&gt; boolean | eqAny: T =&gt; table =&gt; boolean | . Form 1.eqAny returns whether a value is equal to any member of an Array. e.eqAny(7, [4, 5, 9]).query { text: '$1 = any($2))', args: [7, [4, 5, 9]] } . Form 2.eqAny returns whether a value is equal to any row of a Table. e.eqAny(6, sq.sql`select 5 union (select 7)`).query { text: \"$1 = any((select 5 union (select 7)))\", args: [6] } .eqAny is equivalent to .in when the second argument is a table, but their overloads are different.eqAny generates a single parameter from it Postgres Array.in independently parameterizes each entry of its Values List. e.eqAny(4, [3, 4, 5]).query { text: '$1 = any($2)', args: [4, [3, 4, 5]] } e.in(4, [3, 4, 5]).query { text: '$1 in ($2, $3, $4)', args: [4, 3, 4, 5] } . Equal All . | eqAll: T =&gt; array =&gt; boolean | eqAll: T =&gt; table =&gt; boolean | . Form 1.eqAll returns whether a value is equal to all members of an Array. e.eqAll(7, [7, 7, 7]).query { text: '$1 = all($2))', args: [7, [7, 7, 7]] } . Form 2.eqAll returns whether a value is equal to all rows of a Table. e.eqAll(6, sq.sql`select 5 union (select 7)`).query { text: \"$1 = all((select 5 union (select 7)))\", args: [6] } .eqAll is not equivalent to .in. Try .eqAny instead. Not Equal Any . | neqAny: T =&gt; array =&gt; boolean | neqAny: T =&gt; table =&gt; boolean | . Form 1.neqAny returns whether a value is not equal to any member of an Array. e.neqAny(7, [4, 5, 9]).query { text: '$1 &lt;&gt; any($2))', args: [7, [4, 5, 9]] } . Form 2.neqAny returns whether a value is equal not to any row of a Table. e.neqAny(6, sq.sql`select 5 union (select 7)`).query { text: \"$1 &lt;&gt; any((select 5 union (select 7)))\", args: [6] } .neqAny is not equivalent to .notIn. Try .neqAll instead. Not Equal All . | neqAll: T =&gt; array =&gt; boolean | neqAll: T =&gt; table =&gt; boolean | . Form 1.neqAll returns whether a value is not equal to all members of an Array. e.neqAll(7, [7, 7, 7]).query { text: '$1 &lt;&gt; all($2))', args: [7, [7, 7, 7]] } . Form 2.neqAll returns whether a value is not equal to all rows of a Table. e.neqAll(6, sq.sql`select 5 union (select 7)`).query { text: \"$1 &lt;&gt; all((select 5 union (select 7)))\", args: [6] } .notEqAll is equivalent to .notIn when the second argument is a table, but their overloads are different.neqAll generates a single parameter from it Postgres Array.notIn independently parameterizes each entry of its Values List. e.neqAll(4, [3, 4, 5]).query { text: '$1 &lt;&gt; all($2)', args: [4, [3, 4, 5]] } e.notIn(4, [3, 4, 5]).query { text: '$1 not in ($2, $3, $4)', args: [4, 3, 4, 5] } . Less Than Any . | ltAny: T =&gt; array =&gt; boolean | ltAny: T =&gt; table =&gt; boolean | . Form 1.ltAny returns whether a value is less than any member of an Array. e.ltAny(7, [4, 5, 9]).query { text: '$1 &lt; any($2))', args: [7, [4, 5, 9]] } . Form 2.ltAny returns whether a value is less than any row of a Table. e.ltAny(6, sq.sql`select 5 union (select 7)`).query { text: \"$1 &lt; any((select 5 union (select 7)))\", args: [6] } . Less Than All . | ltAll: T =&gt; array =&gt; boolean | ltAll: T =&gt; table =&gt; boolean | . Form 1.ltAll returns whether a value is less than all members of an Array. e.ltAll(7, [4, 5, 9]).query { text: '$1 &lt; all($2))', args: [7, [4, 5, 9]] } . Form 2.ltAll returns whether a value is less than all rows of a Table. e.ltAll(6, sq.sql`select 5 union (select 7)`).query { text: \"$1 &lt; all((select 5 union (select 7)))\", args: [6] } . Greater Than Any . | gtAny: T =&gt; array =&gt; boolean | gtAny: T =&gt; table =&gt; boolean | . Form 1.gtAny returns whether a value is greater than any member of an Array. e.gtAny(7, [4, 5, 9]).query { text: '$1 &gt; any($2))', args: [7, [4, 5, 9]] } . Form 2.gtAny returns whether a value is greater than any row of a Table. e.gtAny(6, sq.sql`select 5 union (select 7)`).query { text: \"$1 &gt; any((select 5 union (select 7)))\", args: [6] } . Greater Than All . | gtAll: T =&gt; array =&gt; boolean | gtAll: T =&gt; table =&gt; boolean | . Form 1.gtAll returns whether a value is greater than all members of an Array. e.gtAll(7, [4, 5, 9]).query { text: '$1 &gt; all($2))', args: [7, [4, 5, 9]] } . Form 2.gtAll returns whether a value is greater than all rows of a Table. e.gtAll(6, sq.sql`select 5 union (select 7)`).query { text: \"$1 &gt; all((select 5 union (select 7)))\", args: [6] } . Less Than or Equal Any . | lteAny: T =&gt; array =&gt; boolean | lteAny: T =&gt; table =&gt; boolean | . Form 1.lteAny returns whether a value is less than or equal to any member of an Array. e.lteAny(7, [4, 5, 9]).query { text: '$1 &lt;= any($2))', args: [7, [4, 5, 9]] } . Form 2.lteAny returns whether a value is less than or equal to any row of a Table. e.lteAny(6, sq.sql`select 5 union (select 7)`).query { text: \"$1 &lt;= any((select 5 union (select 7)))\", args: [6] } . Less Than or Equal All . | lteAll: T =&gt; array =&gt; boolean | lteAll: T =&gt; table =&gt; boolean | . Form 1.lteAll returns whether a value is less than or equal to all members of an Array. e.lteAll(7, [4, 5, 9]).query { text: '$1 &lt;= all($2))', args: [7, [4, 5, 9]] } . Form 2.lteAll returns whether a value is less than or equal to all rows of a Table. e.lteAll(6, sq.sql`select 5 union (select 7)`).query { text: \"$1 &lt;= all((select 5 union (select 7)))\", args: [6] } . Greater Than or Equal Any . | gteAny: T =&gt; array =&gt; boolean | gteAny: T =&gt; table =&gt; boolean | . Form 1.gteAny returns whether a value is greater than or equal to any member of an Array. e.gteAny(7, [4, 5, 9]).query { text: '$1 &gt;= any($2))', args: [7, [4, 5, 9]] } . Form 2.gteAny returns whether a value is greater than or equal to any row of a Table. e.gteAny(6, sq.sql`select 5 union (select 7)`).query { text: \"$1 &gt;= any((select 5 union (select 7)))\", args: [6] } . Greater Than or Equal All . | gteAll: T =&gt; array =&gt; boolean | gteAll: T =&gt; table =&gt; boolean | . Form 1.gteAll returns whether a value is greater than or equal to all members of an Array. e.gteAll(7, [4, 5, 9]).query { text: '$1 &gt;= all($2))', args: [7, [4, 5, 9]] } . Form 2.gteAll returns whether a value is greater than or equal to all rows of a Table. e.gteAll(6, sq.sql`select 5 union (select 7)`).query { text: \"$1 &gt;= all((select 5 union (select 7)))\", args: [6] } . ",
    "url": "http://localhost:4000/docs/operations.html#quantified-comparison",
    "relUrl": "/docs/operations.html#quantified-comparison"
  },"25": {
    "doc": "Operations",
    "title": "Math",
    "content": "Add . | add: number =&gt; number =&gt; number | . Subtract . | sub: number =&gt; number =&gt; number | . Multiply . | mul: number =&gt; number =&gt; number | . Divide . | div: number =&gt; number =&gt; number | . Modulo . | mod: number =&gt; number =&gt; number | . Exponent . | exp: number =&gt; number =&gt; number | . Square Root . | sqrt: number =&gt; number | . Cube Root . | cbrt: number =&gt; number | . Factorial . | fact: number =&gt; number | . ",
    "url": "http://localhost:4000/docs/operations.html#math",
    "relUrl": "/docs/operations.html#math"
  },"26": {
    "doc": "Operations",
    "title": "String",
    "content": "Concatenation Operator . | cat: string =&gt; string =&gt; string | cat: T =&gt; string =&gt; string | cat: string =&gt; T =&gt; string | . See also Concat Function, Array Concatenation Operator and Array Cat . Concat Function . | concat: string =&gt; ...string =&gt; string | . Like . | like: string =&gt; string =&gt; escape | like: string =&gt; string =&gt; .escape =&gt; string =&gt; boolean | . Not Like . | notLike: string =&gt; string =&gt; boolean | notlike: string =&gt; string =&gt; .escape =&gt; string =&gt; boolean | . Like Any . | likeAny: T =&gt; array =&gt; boolean | likeAny: T =&gt; table =&gt; boolean | . Form 1.likeAny returns whether a string is like any member of a String Array. e.likeAny('cat', ['cat', 'dog', 'mouse']).query { text: '$1 like any($2))', args: ['cat', ['cat', 'dog', 'mouse']] } . Form 2.likeAny returns whether a string is like any row of a Table. e.likeAny('cat', sq.sql`select 'cat' union (select 'dog')`).query { text: \"$1 like any((select 'cat' union (select 'dog')))\", args: ['cat'] } . Like All . | likeAll: T =&gt; array =&gt; boolean | likeAll: T =&gt; table =&gt; boolean | . Form 1.likeAll returns whether a string is like all members of a String Array. e.likeAll('cat', ['cat', 'dog', 'mouse']).query { text: '$1 like all($2))', args: ['cat', ['cat', 'dog', 'mouse']] } . Form 2.likeAll returns whether a string is like all rows of a Table. e.likeAll('cat', sq.sql`select 'cat' union (select 'dog')`).query { text: \"$1 like all((select 'cat' union (select 'dog')))\", args: ['cat'] } . Not Like Any . | notLikeAny: T =&gt; array =&gt; boolean | notLikeAny: T =&gt; table =&gt; boolean | . Form 1.notLikeAny returns whether a string is not like any member of a String Array. e.notLikeAny('cat', ['cat', 'dog', 'mouse']).query { text: '$1 not like any($2))', args: ['cat', ['cat', 'dog', 'mouse']] } . Form 2.notLikeAny returns whether a string is not like any row of a Table. e.notLikeAny('cat', sq.sql`select 'cat' union (select 'dog')`).query { text: \"$1 not like any((select 'cat' union (select 'dog')))\", args: ['cat'] } . Not Like All . | notLikeAll: T =&gt; array =&gt; boolean | notLikeAll: T =&gt; table =&gt; boolean | . Form 1.notLikeAll returns whether a string is not like all members of a String Array. e.notLikeAll('cat', ['cat', 'dog', 'mouse']).query { text: '$1 not like all($2))', args: ['cat', ['cat', 'dog', 'mouse']] } . Form 2.notLikeAll returns whether a string is not like all rows of a Table. e.notLikeAll('cat', sq.sql`select 'cat' union (select 'dog')`).query { text: \"$1 not like all((select 'cat' union (select 'dog')))\", args: ['cat'] } . Similar To . | similarTo: string =&gt; string =&gt; boolean | . Not Similar To . | notSimilarTo: string =&gt; string =&gt; boolean | . Lower . | lower: string =&gt; string | . Upper . | upper: string =&gt; string | . ",
    "url": "http://localhost:4000/docs/operations.html#string-1",
    "relUrl": "/docs/operations.html#string-1"
  },"27": {
    "doc": "Operations",
    "title": "Date and Time",
    "content": "Age . TODO . Now . TODO . Extract . TODO . ",
    "url": "http://localhost:4000/docs/operations.html#date-and-time",
    "relUrl": "/docs/operations.html#date-and-time"
  },"28": {
    "doc": "Operations",
    "title": "Range",
    "content": " ",
    "url": "http://localhost:4000/docs/operations.html#range",
    "relUrl": "/docs/operations.html#range"
  },"29": {
    "doc": "Operations",
    "title": "Aggregate",
    "content": "Count . TODO . Sum . TODO . Average . TODO . Min . TODO . Max . TODO . Standard Deviation . TODO . Variance . TODO . ",
    "url": "http://localhost:4000/docs/operations.html#aggregate",
    "relUrl": "/docs/operations.html#aggregate"
  },"30": {
    "doc": "Operations",
    "title": "Conditional",
    "content": "TODO . Case . TODO . Coalesce . TODO . Nullif . TODO . Greatest . TODO . Least . TODO . ",
    "url": "http://localhost:4000/docs/operations.html#conditional",
    "relUrl": "/docs/operations.html#conditional"
  },"31": {
    "doc": "Operations",
    "title": "Array",
    "content": "Concatenation Operator . | array =&gt; array =&gt; array | array =&gt; T =&gt; array | T =&gt; array =&gt; array | . STATUS: TODO . Array Cat . | concat: array =&gt; array =&gt; array | . STATUS: TODO . Array Get . | array =&gt; number =&gt; unknown | . STATUS: TODO . Array Append . | array =&gt; array =&gt; unknown | . STATUS: TODO . Unnest . Reference Postgres . | unnest: array =&gt; ...array =&gt; table | .unnest builds a table from arrays. e.unnest([1, 2, 3]).query // equivalent to (select 1 union all select 2 union all select 3) as unnest(unnest) { text: 'unnest($1)', args: [[1, 2, 3]] } .unnest accepts one or more arrays. e.unnest([1, 2, 3], ['cat', 'dog'], [true]).query { text: 'unnest($1, $2, $3)', args: [[1, 2, 3], ['cat', 'dog'], [true]] } . This table is generated: . | unnest | unnest | unnest | . | 1 | ‘cat’ | true | . | 2 | ‘dog’ | null | . | 3 | null | null | . ",
    "url": "http://localhost:4000/docs/operations.html#array-1",
    "relUrl": "/docs/operations.html#array-1"
  },"32": {
    "doc": "Operations",
    "title": "JSON",
    "content": "TODO . ",
    "url": "http://localhost:4000/docs/operations.html#json-1",
    "relUrl": "/docs/operations.html#json-1"
  },"33": {
    "doc": "Operations",
    "title": "Binary",
    "content": "And . TODO . Or . TODO . Not . TODO . Exclusive Or . TODO . Shift Left . TODO . Shift Right . TODO . ",
    "url": "http://localhost:4000/docs/operations.html#binary",
    "relUrl": "/docs/operations.html#binary"
  },"34": {
    "doc": "Operations",
    "title": "Table",
    "content": "Union . TODO . Union All . TODO . Except . TODO . Except All . TODO . Intersect . TODO . Intersect All . TODO . ",
    "url": "http://localhost:4000/docs/operations.html#table-1",
    "relUrl": "/docs/operations.html#table-1"
  },"35": {
    "doc": "Operations",
    "title": "Operations",
    "content": " ",
    "url": "http://localhost:4000/docs/operations.html",
    "relUrl": "/docs/operations.html"
  },"36": {
    "doc": "Select",
    "title": "Overview",
    "content": ". | With .with .withRecursive | Select .return | Distinct .distinct .distinctOn | From .from .join .leftJoin .rightJoin .fullJoin .crossJoin .naturalJoin .naturalLeftJoin .naturalRightJoin .naturalFullJoin .on .using | Where .where | Group By .groupBy .rollup .cube .groupingSets | Having .having | Sets .union .intersect .except .unionAll .intersectAll .exceptAll | Order By .orderBy | Limit .limit | Offset .offset | . ",
    "url": "http://localhost:4000/docs/select_queries.html#overview",
    "relUrl": "/docs/select_queries.html#overview"
  },"37": {
    "doc": "Select",
    "title": "Initialize",
    "content": "import Easybase from \"easybasejs\"; import ebconfig from \"./ebconfig.js\"; const table = Easybase.EasybaseProvider({ ebconfig }).db(\"MYTABLE\"); const { e } = table; // Optional query expressions . ",
    "url": "http://localhost:4000/docs/select_queries.html#initialize",
    "relUrl": "/docs/select_queries.html#initialize"
  },"38": {
    "doc": "Select",
    "title": "Example Table",
    "content": "For the following queries, consider the data table below: . [ { \"title\": \"Avatar\", \"rating\": 83 }, { \"title\": \"Titanic\", \"rating\": 75 }, { \"title\": \"The Lion King\", \"rating\": 55 }, { \"title\": \"Jurassic World\", \"rating\": 59 } ] . ",
    "url": "http://localhost:4000/docs/select_queries.html#example-table",
    "relUrl": "/docs/select_queries.html#example-table"
  },"39": {
    "doc": "Select",
    "title": "Select",
    "content": ".return builds queries to select from. After building a query of any kind, use .all or .one to execute it. await table.return().all(); [ { \"title\": \"Avatar\", \"rating\": 83 }, { \"title\": \"Titanic\", \"rating\": 75 }, { \"title\": \"The Lion King\", \"rating\": 55 }, { \"title\": \"Jurassic World\", \"rating\": 59 }, ] .one will only return the first match. await table.return().one(); { \"title\": \"Avatar\", \"rating\": 83 } . Pass arguments into .return to select only specific columns. await table.return(\"title\").one(); { \"title\": \"Avatar\" } . ",
    "url": "http://localhost:4000/docs/select_queries.html",
    "relUrl": "/docs/select_queries.html"
  },"40": {
    "doc": "Select",
    "title": "Where",
    "content": ".where builds where clauses. Expressions, e, are are used to create comparisons and boolean logic. Learn more about expressions. await table.return().where(e.eq(\"title\", \"The Lion King\")).one() { \"title\": \"The Lion King\", \"rating\": 55 } . Conditions can be objects in the form { field: value }. Each property generates a field = value clause. await table.return().where({ title: \"The Lion King\", rating: 55 }).all() [ { \"title\": \"The Lion King\", \"rating\": 55 } ] . Use Expressions to build complex conditions with e.and, e.or and e.not. await table.return().where( e.or( e.eq(\"title\", \"The Lion King\"), // Equals e.gt(\"rating\", 80) // Greater than ) ).all() [ { \"title\": \"Avatar\", \"rating\": 83 }, { \"title\": \"The Lion King\", \"rating\": 55 } ] . array arguments generate a field in values expression. await table.return().where({ rating: [55, 56, 57, 58, 59] }).all() [ { \"title\": \"The Lion King\", \"rating\": 55 }, { \"title\": \"Jurassic World\", \"rating\": 59 } ] . ",
    "url": "http://localhost:4000/docs/select_queries.html#where",
    "relUrl": "/docs/select_queries.html#where"
  },"41": {
    "doc": "Select",
    "title": "Order By",
    "content": "Specify row ordering with .orderBy. This function accepts objects. Property by is used for ordering. It can be a string, Expression, Fragment or Subqueries. Set property sort to either 'asc' or 'desc'. await table().return().orderBy({ by: \"rating\", sort: \"asc\" }).all() [ { \"title\": \"The Lion King\", \"rating\": 55 }, { \"title\": \"Jurassic World\", \"rating\": 59 }, { \"title\": \"Titanic\", \"rating\": 75 }, { \"title\": \"Avatar\", \"rating\": 83 } ] .orderBy accepts multiple sort objects, which will be evaluated in order. await table().return().orderBy({ by: \"rating\", sort: \"asc\" }, { by: \"title\", sort: \"desc\" }).all() [ { \"title\": \"The Lion King\", \"rating\": 55 }, { \"title\": \"Jurassic World\", \"rating\": 59 }, { \"title\": \"Titanic\", \"rating\": 75 }, { \"title\": \"Avatar\", \"rating\": 83 } ] . ",
    "url": "http://localhost:4000/docs/select_queries.html#order-by",
    "relUrl": "/docs/select_queries.html#order-by"
  },"42": {
    "doc": "Select",
    "title": "Limit",
    "content": "Pass .limit the maximum number of rows to fetch. await table.return().limit(2).all() [ { \"title\": \"Avatar\", \"rating\": 83 }, { \"title\": \"Titanic\", \"rating\": 75 } ] . ",
    "url": "http://localhost:4000/docs/select_queries.html#limit",
    "relUrl": "/docs/select_queries.html#limit"
  },"43": {
    "doc": "Select",
    "title": "Offset",
    "content": "Pass .offset the number of rows to skip before returning rows. await table.return().offset(1).all() [ { \"title\": \"Titanic\", \"rating\": 75 }, { \"title\": \"The Lion King\", \"rating\": 55 }, { \"title\": \"Jurassic World\", \"rating\": 59 } ] .offset and .limit can be used in conjugation for pagination of your data table. let page = 0; await table.return().limit(2).offset(page * 2).all(); [ { \"title\": \"Avatar\", \"rating\": 83 }, { \"title\": \"Titanic\", \"rating\": 75 } ] page++; await table.return().limit(2).offset(page * 2).all(); [ { \"title\": \"The Lion King\", \"rating\": 55 }, { \"title\": \"Jurassic World\", \"rating\": 59 } ] . ",
    "url": "http://localhost:4000/docs/select_queries.html#offset",
    "relUrl": "/docs/select_queries.html#offset"
  },"44": {
    "doc": "Select",
    "title": "Joins",
    "content": ".join, .leftJoin, .rightJoin and .fullJoin build inner, left, right and full joins respectively. Either .on or .using must be called immediately after. sq.from`book`.join`author`.on`book.author_id = author.id`.query { text: 'select * from book join author on (book.author_id = author.id)', args: [] } .naturalJoin, .naturalLeftJoin, .naturalRightJoin and .naturalFullJoin build natural joins. Calling .on or .using after a natural join is invalid. sq.from`book`.naturalRightJoin`author`.query { text: 'select * from book natural right join author', args: [] } .crossJoin builds a cross join. sq.from`book`.crossJoin`author`.query { text: 'select * from book cross join author', args: [] } . Join methods accept the same arguments as .from. sq.from({ b: 'book' }) .naturalFullJoin({ a: 'author' }) .naturalRightJoin('publisher') .query { text: 'select book b natural full join author a natural right join publisher', args: [] } . On .on specifies join conditions. It accepts the same arguments as .where.on must be called exactly once. sq.from({ b: 'book' }) .join({ a: 'author'}).on({ 'b.author_id': sq.raw('a.id') }) .query { text: 'select * from book b join author a on (b.author_id = a.id)', args: [] } . Build complex join conditions with Expressions. sq.from({ t: 'ticket' }) .leftJoin({ p: 'person' }) .on(e.or( e.eq`p.first_name``t.first_name`, e.eq`p.last_name``t.last_name` )) .query { text: 'select * from ticket t left join person p on ((p.first_name = t.first_name) or (p.last_name = t.last_name))', args: [] } . Using . Alternatively, specify join columns with .using.using must be called exactly once. sq.from`book`.join`author`.using`author_id`.query { text: 'select * from book join author using (author_id)', args: [] } .using accepts strings. sq.from('a').join('b').using('x', 'y', 'z').query { text: 'select * from a join b using (x, y, z)', args: [] } . ",
    "url": "http://localhost:4000/docs/select_queries.html#joins",
    "relUrl": "/docs/select_queries.html#joins"
  },"45": {
    "doc": "Select",
    "title": "Sets",
    "content": "Union, Intersect, Except . Pass select subqueries to .union, .intersect and .except to perform set operations. const Person = sq.from`person` const Young = Person.where`age &lt; 30` const Middle = Person.where`age &gt;= 30 and age &lt; 60` const Old = Person.where`age &gt;= 60` Person.except(Young).query { text: 'select * from person except (select * from person where (age &lt; 30))', args: [] } Young.union(Middle, Old).query { text: 'select * from person where (age &lt; 30) union (select * from person where (age &gt;= 30 and age &lt; 60)) union (select * from person where (age &gt;= 60))', args: [] } . Union All, Intersect All, Except All .unionAll, .intersectAll and .exceptAll can be used to prevent duplicate elimination. Young.unionAll(Old).query { text: 'select * from person where (age &lt; 30) union all (select * from person where (age &gt;= 60))', args: [] } . Set operators can be chained. Person.except(Young).intersect(Person.except(Old)).query { text: 'select * from person except (select * from person where (age &lt; 30)) intersect (select * from person except (select * from person where (age &gt;= 60)))', args: [] } . ",
    "url": "http://localhost:4000/docs/select_queries.html#sets",
    "relUrl": "/docs/select_queries.html#sets"
  },"46": {
    "doc": "Select",
    "title": "With",
    "content": "Construct CTEs (Common Table Expressions) with .with. sq.with`n (select ${20} age)`.from`n`.return`age`.query { text: 'with n (select $1 age) select age from n', args: [20] } .with can be called multiple times. sq.with`width (select ${10} n)` .with`height (select ${20} n)` .return`width.n * height.n area` .query { text: 'with width (select $1 n), height (select $2 n) select width.n * height.n area', args: [10, 20] } .with accepts objects in the form { alias: table }. Tables can be Subqueries. sq.with({ width: sq.return({ n: 10 }), height: sq.sql`select ${20} n` }) .return({ area: sq.txt`width.n * height.n` }) .query { text: 'with width (select $1 n), height (select $2 n) select width.n * height.n area', args: [10, 20] } . Tables can be arrays of row objects. A values clause is generated. Column names are inferred from all keys. const people = [{ age: 7, name: 'Jo' }, { age: 9, name: 'Mo' }] sq.with({ people }).return`max(age)`.from`people`.query { text: 'with people(age, name) (values ($1, $2), ($3, $4)) select max(age) from people', args: [7, 'Jo', 9, 'Mo'] } . Recursive CTEs .withRecursive creates a recursive CTE. const one = sq.return`1` const next = sq.return`n + 1`.from`t`.where`n &lt; 100` sq.withRecursive({ 't(n)': one.unionAll(next) }) .from('t') .return('sum(n)') .query { text: 'with recursive t(n) (select 1 union all (select n + 1 from t where (n &lt; 100))) select sum(n) from t', args: [] } . ",
    "url": "http://localhost:4000/docs/select_queries.html#with",
    "relUrl": "/docs/select_queries.html#with"
  },"47": {
    "doc": "Update",
    "title": "Overview",
    "content": ". | With .with .withRecursive | Update .from | Set .set | From .from | Where .where | Returning .return | . ",
    "url": "http://localhost:4000/docs/update_queries.html#overview",
    "relUrl": "/docs/update_queries.html#overview"
  },"48": {
    "doc": "Update",
    "title": "Set",
    "content": ".from specifies the table to modify and .set specifies the fields to update.from works it does in Delete queries. sq.from`person` .set`age = age + 1, name = ${'Sally'}` .query { text: 'update person set age = age + 1, name = $1', args: ['Sally'] } . Multiple calls to .set are joined with ', '. sq.from`person` .set`age = age + 1` .set`name = ${'Sally'}` .query { text: 'update person set age = age + 1, name = $1', args: ['Sally'] } .set accepts objects in the form { field: value }. Each property generates a field = value clause. sq.from('person') .set( { firstName: 'Robert', nickname: 'Rob' }, { processed: true } ) .query { text: 'update person set first_name = $1, nickname = $2, processed = $3', args: ['Robert', 'Rob', true] } . Values can be Expressions. sq.from('person') .set({ age: e.add(3, 4) }) .query { text: 'update person set age = ($1 + $2)', args: [3, 4] } . Values can be Fragments. sq.from('person') .set({ age: sq.txt`3 + 4` }) .query { text: 'update person set age = 3 + 4', args: [] } . Values can be Subqueries. sq.from('person') .set({ firstName: sq.sql`select 'Bob'`, lastName: sq.return`'Smith'` }) .query { text: \"update person set first_name = (select 'Bob'), last_name = (select 'Smith')\", args: [] } . ",
    "url": "http://localhost:4000/docs/update_queries.html#set",
    "relUrl": "/docs/update_queries.html#set"
  },"49": {
    "doc": "Update",
    "title": "Where",
    "content": "Filter the rows to update with .where. sq.from`person` .where({ firstName: 'Matt' }) .set({ firstName: 'Robert', nickname: 'Rob' }) .query { text: 'update person set first_name = $1, nickname = $2 where (first_name = $3)', args: ['Robert', 'Rob', 'Matt'] } .where works it does in Select queries. ",
    "url": "http://localhost:4000/docs/update_queries.html#where",
    "relUrl": "/docs/update_queries.html#where"
  },"50": {
    "doc": "Update",
    "title": "From",
    "content": "Postgres Only: The first .from call forms the update clause. Subsequent .from calls form the from clause. sq.from`book` .from`author` .set({ available: false }) .where`book.author_id = author.id and author.contract = 'terminated'` .query { text: \"update book set available = $1 from author where (book.author_id = author.id and author.contract = 'terminated')\", args: [false] } . ",
    "url": "http://localhost:4000/docs/update_queries.html#from",
    "relUrl": "/docs/update_queries.html#from"
  },"51": {
    "doc": "Update",
    "title": "Returning",
    "content": "Postgres Only: Return the updated rows with .return. sq.from`person` .where`age &gt; 60 and old = false` .set`old = true` .return`id, age` .query { text: 'update person set old = true where (age &gt; 60 and old = false) returning id, age', args: [] } . ",
    "url": "http://localhost:4000/docs/update_queries.html#returning",
    "relUrl": "/docs/update_queries.html#returning"
  },"52": {
    "doc": "Update",
    "title": "Express",
    "content": "Express syntax works. sq`person`({ firstName: 'Rob' })`id`.set({ firstName: 'Robert'}).query { text: 'update person set first_name = $1 where first_name = $2 returning id', args: ['Robert', 'Rob'] } . ",
    "url": "http://localhost:4000/docs/update_queries.html#express",
    "relUrl": "/docs/update_queries.html#express"
  },"53": {
    "doc": "Update",
    "title": "Update",
    "content": " ",
    "url": "http://localhost:4000/docs/update_queries.html",
    "relUrl": "/docs/update_queries.html"
  }
}
