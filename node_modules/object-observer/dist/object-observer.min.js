function i(e,t){if("function"!=typeof e)throw new Error(`observer MUST be a function, got '${e}'`);const r=this[g].observers;r.some(t=>t[0]===e)?console.warn("observer may be bound to an observable only once; will NOT rebind"):r.push([e,(t=>{if(!t||"object"!=typeof t)return null;const e={},r=[];for(var[o,n]of Object.entries(t))if("path"===o){if("string"!=typeof n||""===n)throw new Error('"path" option, if/when provided, MUST be a non-empty string');e[o]=n}else if("pathsOf"===o){if(t.path)throw new Error('"pathsOf" option MAY NOT be specified together with "path" option');if("string"!=typeof n)throw new Error('"pathsOf" option, if/when provided, MUST be a string (MAY be empty)');e[o]=t.pathsOf.split(".").filter(Boolean)}else if("pathsFrom"===o){if(t.path||t.pathsOf)throw new Error('"pathsFrom" option MAY NOT be specified together with "path"/"pathsOf" option/s');if("string"!=typeof n||""===n)throw new Error('"pathsFrom" option, if/when provided, MUST be a non-empty string');e[o]=n}else r.push(o);if(r.length)throw new Error(`'${r.join(", ")}' is/are not a valid observer option/s`);return e})(t)])}function r(...t){const e=this[g].observers;let r=e.length;if(r)if(t.length)for(;r;)0<=t.indexOf(e[--r][0])&&e.splice(r,1);else e.splice(0)}function t(){const t=this[g],e=t.target;let r,o,n;for(e.reverse(),r=0,o=e.length;r<o;r++)if((n=e[r])&&"object"==typeof n){const i=n[g];i&&(i.ownKey=r)}var s=[new m(l,[],void 0,void 0,this)];return j(t,s),this}function e(t){const e=this[g],r=e.target;let o,n,s;for(r.sort(t),o=0,n=r.length;o<n;o++)if((s=r[o])&&"object"==typeof s){const i=s[g];i&&(i.ownKey=o)}return t=[new m(f,[],void 0,void 0,this)],j(e,t),this}function h(t,n,s){const i=this[g],h=i.target,a=[],e=h.length,l=h.slice(0);if(n=void 0===n?0:n<0?Math.max(e+n,0):Math.min(n,e),s=void 0===s?e:s<0?Math.max(e+s,0):Math.min(s,e),n<e&&n<s){h.fill(t,n,s);let o;for(let t=n,e,r;t<s;t++)e=h[t],h[t]=O(e,t,i),t in l?((r=l[t])&&"object"==typeof r&&(o=r[g])&&(r=o.detach()),a.push(new m(v,[t],h[t],r,this))):a.push(new m(w,[t],h[t],void 0,this));j(i,a)}return this}function a(n,t,e){const s=this[g],i=s.target,r=i.length;n=n<0?Math.max(r+n,0):n,t=void 0===t?0:t<0?Math.max(r+t,0):Math.min(t,r),e=void 0===e?r:e<0?Math.max(r+e,0):Math.min(e,r);var h=Math.min(e-t,r-n);if(n<r&&n!==t&&0<h){const a=i.slice(0),l=[];i.copyWithin(n,t,e);for(let t=n,e,r,o;t<n+h;t++)(e=i[t])&&"object"==typeof e&&(e=O(e,t,s),i[t]=e),(r=a[t])&&"object"==typeof r&&(o=r[g])&&(r=o.detach()),"object"!=typeof e&&e===r||l.push(new m(v,[t],e,r,this));j(s,l)}return this}const w="insert",v="update",d="delete",l="reverse",f="shuffle",g=Symbol.for("object-observer-meta-key-0"),p={async:1},c={observe:{value:i},unobserve:{value:r}},b=(t,e)=>{const r=Object.defineProperties({},c);r[g]=e;for(const o in t)r[o]=O(t[o],o,e);return r},u=(e,r)=>{var o=e.length;const n=Object.defineProperties(new Array(o),c);n[g]=r;for(let t=0;t<o;t++)n[t]=O(e[t],t,r);return n},y=(t,e)=>(Object.defineProperties(t,c),t[g]=e,t),x=(t,e)=>{if(!t)return e;let r=e;if(t.path){const o=t.path;r=e.filter(t=>t.path.join(".")===o)}else if(t.pathsOf){const n=t.pathsOf,s=n.join(".");r=e.filter(t=>(t.path.length===n.length+1||t.path.length===n.length&&(t.type===l||t.type===f))&&t.path.join(".").startsWith(s))}else if(t.pathsFrom){const i=t.pathsFrom;r=e.filter(t=>t.path.join(".").startsWith(i))}return r},M=(e,r)=>{try{e(r)}catch(t){console.error(`failed to notify listener ${e} with `+r,t)}},A=function(){var t,e,r=this.batches;this.batches=null;for([t,e]of r)M(t,e)},j=(f,e)=>{let r=f,t,o,n,s,i;var h=e.length;do{for(t=r.observers,i=t.length;i--;)if([o,n]=t[i],(s=x(n,e)).length)if(r.options.async){r.batches||(r.batches=[],queueMicrotask(A.bind(r)));let t;for(const a of r.batches)if(a[0]===o){t=a;break}t||(t=[o,[]],r.batches.push(t)),Array.prototype.push.apply(t[1],s)}else M(o,s);if(r.parent){const l=new Array(h);for(let t=0;t<h;t++)l[t]={...e[t]},l[t].path=[r.ownKey,...l[t].path];e=l,r=r.parent}else r=null}while(r)},O=(t,e,r)=>t&&"object"==typeof t?Array.isArray(t)?new k({target:t,ownKey:e,parent:r}).proxy:ArrayBuffer.isView(t)?new Y({target:t,ownKey:e,parent:r}).proxy:t instanceof Date?t:new T({target:t,ownKey:e,parent:r}).proxy:t,K={pop:function(){const t=this[g],e=t.target,r=e.length-1;let o=e.pop();if(o&&"object"==typeof o){const s=o[g];s&&(o=s.detach())}var n=[new m(d,[r],void 0,o,this)];return j(t,n),o},push:function(){const e=this[g],r=e.target,o=arguments.length,n=new Array(o),s=r.length;for(let t=0;t<o;t++)n[t]=O(arguments[t],s+t,e);var t=Reflect.apply(r.push,r,n);const i=[];for(let t=s,e=r.length;t<e;t++)i[t-s]=new m(w,[t],r[t],void 0,this);return j(e,i),t},shift:function(){const t=this[g],e=t.target;let r,o,n,s,i;for((r=e.shift())&&"object"==typeof r&&(i=r[g])&&(r=i.detach()),o=0,n=e.length;o<n;o++)(s=e[o])&&"object"==typeof s&&(i=s[g])&&(i.ownKey=o);var h=[new m(d,[0],void 0,r,this)];return j(t,h),r},unshift:function(){const e=this[g],o=e.target,r=arguments.length,n=new Array(r);for(let t=0;t<r;t++)n[t]=O(arguments[t],t,e);var t=Reflect.apply(o.unshift,o,n);for(let t=0,e=o.length,r;t<e;t++)if((r=o[t])&&"object"==typeof r){const h=r[g];h&&(h.ownKey=t)}var s=n.length;const i=new Array(s);for(let t=0;t<s;t++)i[t]=new m(w,[t],o[t],void 0,this);return j(e,i),t},reverse:t,sort:e,fill:h,copyWithin:a,splice:function(){const e=this[g],r=e.target,o=arguments.length,n=new Array(o),f=r.length;for(let t=0;t<o;t++)n[t]=O(arguments[t],t,e);const t=0===o?0:n[0]<0?f+n[0]:n[0],p=o<2?f-t:n[1],c=Math.max(o-2,0),s=Reflect.apply(r.splice,r,n),b=r.length;let i;for(let t=0,e;t<b;t++)(e=r[t])&&"object"==typeof e&&(i=e[g])&&(i.ownKey=t);let h,u,y;for(h=0,u=s.length;h<u;h++)(y=s[h])&&"object"==typeof y&&(i=y[g])&&(s[h]=i.detach());const a=[];let l;for(l=0;l<p;l++)l<c?a.push(new m(v,[t+l],r[t+l],s[l],this)):a.push(new m(d,[t+l],void 0,s[l],this));for(;l<c;l++)a.push(new m(w,[t+l],r[t+l],void 0,this));return j(e,a),s}},E={reverse:t,sort:e,fill:h,copyWithin:a,set:function(t,e){const r=this[g],o=r.target,n=t.length,s=o.slice(0),i=(e=e||0,o.set(t,e),new Array(n));for(let t=e;t<n+e;t++)i[t-e]=new m(v,[t],o[t],s[t],this);j(r,i)}};class m{constructor(t,e,r,o,n){this.type=t,this.path=e,this.value=r,this.oldValue=o,this.object=n}}class S{constructor(t,e){var{target:r,parent:o,ownKey:n}=t,o=(o&&void 0!==n?(this.parent=o,this.ownKey=n):(this.parent=null,this.ownKey=null),e(r,this));this.observers=[],this.revocable=Proxy.revocable(o,this),this.proxy=this.revocable.proxy,this.target=o,this.options=this.processOptions(t.options)}processOptions(t){if(t){if("object"!=typeof t)throw new Error(`Observable options if/when provided, MAY only be an object, got '${t}'`);const e=Object.keys(t).filter(t=>!(t in p));if(e.length)throw new Error(`'${e.join(", ")}' is/are not a valid Observable option/s`);return Object.assign({},t)}return{}}detach(){return this.parent=null,this.target}set(t,e,r){let o=t[e];if(r!==o){r=O(r,e,this);if(t[e]=r,o&&"object"==typeof o){const n=o[g];n&&(o=n.detach())}t=void 0===o?[new m(w,[e],r,void 0,this.proxy)]:[new m(v,[e],r,o,this.proxy)];j(this,t)}return!0}deleteProperty(t,e){let r=t[e];if(delete t[e],r&&"object"==typeof r){const o=r[g];o&&(r=o.detach())}t=[new m(d,[e],void 0,r,this.proxy)];return j(this,t),!0}}class T extends S{constructor(t){super(t,b)}}class k extends S{constructor(t){super(t,u)}get(t,e){return K[e]||t[e]}}class Y extends S{constructor(t){super(t,y)}get(t,e){return E[e]||t[e]}}const o=Object.freeze({from:(t,e)=>{if(t&&"object"==typeof t){if(t[g])return t;if(Array.isArray(t))return new k({target:t,ownKey:null,parent:null,options:e}).proxy;if(ArrayBuffer.isView(t))return new Y({target:t,ownKey:null,parent:null,options:e}).proxy;if(t instanceof Date)throw new Error(t+" found to be one of a non-observable types");return new T({target:t,ownKey:null,parent:null,options:e}).proxy}throw new Error("observable MAY ONLY be created from a non-null object")},isObservable:t=>!(!t||!t[g]),observe:(t,e,r)=>{if(!o.isObservable(t))throw new Error("invalid observable parameter");i.call(t,e,r)},unobserve:(t,...e)=>{if(!o.isObservable(t))throw new Error("invalid observable parameter");r.call(t,...e)}}),n=Symbol("observer-key"),s=Symbol("targets-key");class F{constructor(t){this[n]=t,this[s]=new Set,Object.freeze(this)}observe(t,e){const r=o.from(t);return r.observe(this[n],e),this[s].add(r),r}unobserve(t){t.unobserve(this[n]),this[s].delete(t)}disconnect(){for(const t of this[s])t.unobserve(this[n]);this[s].clear()}}export{o as Observable,F as ObjectObserver};